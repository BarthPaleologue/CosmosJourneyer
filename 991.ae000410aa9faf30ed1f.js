
//  This file is part of Cosmos Journeyer
//
//  Copyright (C) 2024 Barthélemy Paléologue <barth.paleologue@cosmosjourneyer.com>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Affero General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Affero General Public License for more details.
//
//  You should have received a copy of the GNU Affero General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
        
"use strict";(self.webpackChunkcosmos_journeyer=self.webpackChunkcosmos_journeyer||[]).push([[991],{7913:(t,e,r)=>{function i(t,e){const r=[];for(let i=0;i<t;++i)r.push(e());return r}function s(t,e){return i(t,e)}r.d(e,{lL:()=>n,ln:()=>s,mI:()=>i});const o=["push","splice","pop","shift","unshift"];function n(t,e){const r=o.map((r=>function(t,e,r){const i=t[e];if("function"!=typeof i)return null;const s=function(){const i=t.length,o=s.previous.apply(t,arguments);return r(e,i),o};return i.next=s,s.previous=i,t[e]=s,()=>{const r=s.previous;if(!r)return;const i=s.next;i?(r.next=i,i.previous=r):(r.next=void 0,t[e]=r),s.next=void 0,s.previous=void 0}}(t,r,e)));return()=>{r.forEach((t=>{t?.()}))}}},19779:(t,e,r)=>{r.d(e,{a6:()=>o,bH:()=>n,rv:()=>i,tk:()=>s});const i=1/2.2,s=2.2,o=(1+Math.sqrt(5))/2,n=.001},33583:(t,e,r)=>{function i(t){return parseInt(t.toString().replace(/\W/g,""))}function s(t,e,r=1401298e-51){return Math.abs(t-e)<=r}function o(t,e){return t===e?t:Math.random()*(e-t)+t}function n(t,e,r){return t+(e-t)*r}function a(t,e,r){let i=x(e-t,360);return i>180&&(i-=360),t+i*y(r)}function h(t,e,r){let i=0;return i=t!=e?y((r-t)/(e-t)):0,i}function _(t,e,r,i,s){const o=s*s,n=s*o;return t*(2*n-3*o+1)+r*(-2*n+3*o)+e*(n-2*o+s)+i*(n-o)}function c(t,e,r,i,s){const o=s*s;return 6*(o-s)*t+(3*o-4*s+1)*e+6*(-o+s)*r+(3*o-2*s)*i}function y(t,e=0,r=1){return Math.min(r,Math.max(e,t))}function l(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function u(t){const e=t.toString(16);return t<=15?("0"+e).toUpperCase():e.toUpperCase()}function m(t){if(Math.log2)return Math.floor(Math.log2(t));if(t<0)return NaN;if(0===t)return-1/0;let e=0;if(t<1){for(;t<1;)e++,t*=2;e=-e}else if(t>1)for(;t>1;)e++,t=Math.floor(t/2);return e}function x(t,e){return t-Math.floor(t/e)*e}function f(t,e,r){return(t-e)/(r-e)}function R(t,e,r){return t*(r-e)+e}function d(t,e){let r=x(e-t,360);return r>180&&(r-=360),r}function z(t,e){const r=x(t,2*e);return e-Math.abs(r-e)}function T(t,e,r){let i=y(r);return i=-2*i*i*i+3*i*i,e*i+t*(1-i)}function w(t,e,r){let i=0;return i=Math.abs(e-t)<=r?e:t+Math.sign(e-t)*r,i}function p(t,e,r){const i=d(t,e);let s=0;return s=-r<i&&i<r?e:w(t,e=t+i,r),s}function F(t,e,r){return(t-e)/(r-e)}function M(t,e,r){return(r-e)*t+e}function I(t,e){const r=t%e;return 0===r?e:I(e,r)}r.r(e),r.d(e,{Clamp:()=>y,DeltaAngle:()=>d,Denormalize:()=>R,ExtractAsInt:()=>i,Hermite:()=>_,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>I,ILog2:()=>m,InverseLerp:()=>h,Lerp:()=>n,LerpAngle:()=>a,MoveTowards:()=>w,MoveTowardsAngle:()=>p,Normalize:()=>f,NormalizeRadians:()=>l,PercentToRange:()=>M,PingPong:()=>z,RandomRange:()=>o,RangeToPercent:()=>F,Repeat:()=>x,SmoothStep:()=>T,ToHex:()=>u,WithinEpsilon:()=>s})},34991:(t,e,r)=>{r.d(e,{AA:()=>f,I9:()=>c,IU:()=>l,PT:()=>u,Pq:()=>y,uq:()=>m});var i=r(19779),s=r(7913),o=r(9300),n=r(41355),a=r(44903),h=r(33583);const _=t=>parseInt(t.toString().replace(/\W/g,""));class c{constructor(t=0,e=0){this.x=t,this.y=e}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let t=_(this.x);return t=397*t^_(this.y),t}toArray(t,e=0){return t[e]=this.x,t[e+1]=this.y,this}fromArray(t,e=0){return c.FromArrayToRef(t,e,this),this}asArray(){return[this.x,this.y]}copyFrom(t){return this.x=t.x,this.y=t.y,this}copyFromFloats(t,e){return this.x=t,this.y=e,this}set(t,e){return this.copyFromFloats(t,e)}setAll(t){return this.copyFromFloats(t,t)}add(t){return new c(this.x+t.x,this.y+t.y)}addToRef(t,e){return e.x=this.x+t.x,e.y=this.y+t.y,e}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addInPlaceFromFloats(t,e){return this.x+=t,this.y+=e,this}addVector3(t){return new c(this.x+t.x,this.y+t.y)}subtract(t){return new c(this.x-t.x,this.y-t.y)}subtractToRef(t,e){return e.x=this.x-t.x,e.y=this.y-t.y,e}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new c(this.x*t.x,this.y*t.y)}multiplyToRef(t,e){return e.x=this.x*t.x,e.y=this.y*t.y,e}multiplyByFloats(t,e){return new c(this.x*t,this.y*e)}divide(t){return new c(this.x/t.x,this.y/t.y)}divideToRef(t,e){return e.x=this.x/t.x,e.y=this.y/t.y,e}divideInPlace(t){return this.x=this.x/t.x,this.y=this.y/t.y,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.x,t.y)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.x,t.y)}minimizeInPlaceFromFloats(t,e){return this.x=Math.min(t,this.x),this.y=Math.min(e,this.y),this}maximizeInPlaceFromFloats(t,e){return this.x=Math.max(t,this.x),this.y=Math.max(e,this.y),this}subtractFromFloats(t,e){return new c(this.x-t,this.y-e)}subtractFromFloatsToRef(t,e,r){return r.x=this.x-t,r.y=this.y-e,r}negate(){return new c(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){return new c(this.x*t,this.y*t)}scaleToRef(t,e){return e.x=this.x*t,e.y=this.y*t,e}scaleAndAddToRef(t,e){return e.x+=this.x*t,e.y+=this.y*t,e}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t,e=i.bH){return t&&(0,h.WithinEpsilon)(this.x,t.x,e)&&(0,h.WithinEpsilon)(this.y,t.y,e)}equalsToFloats(t,e){return this.x===t&&this.y===e}floor(){return new c(Math.floor(this.x),Math.floor(this.y))}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t}fract(){return new c(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t}rotateToRef(t,e){const r=Math.cos(t),i=Math.sin(t),s=r*this.x-i*this.y,o=i*this.x+r*this.y;return e.x=s,e.y=o,e}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new c;return this.normalizeToRef(t),t}normalizeToRef(t){const e=this.length();return 0===e&&(t.x=this.x,t.y=this.y),this.scaleToRef(1/e,t)}clone(){return new c(this.x,this.y)}dot(t){return this.x*t.x+this.y*t.y}static Zero(){return new c(0,0)}static One(){return new c(1,1)}static Random(t=0,e=1){return new c((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static RandomToRef(t=0,e=1,r){return r.copyFromFloats((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static get ZeroReadOnly(){return c._ZeroReadOnly}static FromArray(t,e=0){return new c(t[e],t[e+1])}static FromArrayToRef(t,e,r){return r.x=t[e],r.y=t[e+1],r}static FromFloatsToRef(t,e,r){return r.copyFromFloats(t,e),r}static CatmullRom(t,e,r,i,s){const o=s*s,n=s*o,a=.5*(2*e.x+(-t.x+r.x)*s+(2*t.x-5*e.x+4*r.x-i.x)*o+(-t.x+3*e.x-3*r.x+i.x)*n),h=.5*(2*e.y+(-t.y+r.y)*s+(2*t.y-5*e.y+4*r.y-i.y)*o+(-t.y+3*e.y-3*r.y+i.y)*n);return new c(a,h)}static ClampToRef(t,e,r,i){return i.x=(0,h.Clamp)(t.x,e.x,r.x),i.y=(0,h.Clamp)(t.y,e.y,r.y),i}static Clamp(t,e,r){const i=(0,h.Clamp)(t.x,e.x,r.x),s=(0,h.Clamp)(t.y,e.y,r.y);return new c(i,s)}static Hermite(t,e,r,i,s){const o=s*s,n=s*o,a=2*n-3*o+1,h=-2*n+3*o,_=n-2*o+s,y=n-o,l=t.x*a+r.x*h+e.x*_+i.x*y,u=t.y*a+r.y*h+e.y*_+i.y*y;return new c(l,u)}static Hermite1stDerivative(t,e,r,i,s){return this.Hermite1stDerivativeToRef(t,e,r,i,s,new c)}static Hermite1stDerivativeToRef(t,e,r,i,s,o){const n=s*s;return o.x=6*(n-s)*t.x+(3*n-4*s+1)*e.x+6*(-n+s)*r.x+(3*n-2*s)*i.x,o.y=6*(n-s)*t.y+(3*n-4*s+1)*e.y+6*(-n+s)*r.y+(3*n-2*s)*i.y,o}static Lerp(t,e,r){return c.LerpToRef(t,e,r,new c)}static LerpToRef(t,e,r,i){return i.x=t.x+(e.x-t.x)*r,i.y=t.y+(e.y-t.y)*r,i}static Dot(t,e){return t.x*e.x+t.y*e.y}static Normalize(t){return c.NormalizeToRef(t,new c)}static NormalizeToRef(t,e){return t.normalizeToRef(e),e}static Minimize(t,e){const r=t.x<e.x?t.x:e.x,i=t.y<e.y?t.y:e.y;return new c(r,i)}static Maximize(t,e){const r=t.x>e.x?t.x:e.x,i=t.y>e.y?t.y:e.y;return new c(r,i)}static Transform(t,e){return c.TransformToRef(t,e,new c)}static TransformToRef(t,e,r){const i=e.m,s=t.x*i[0]+t.y*i[4]+i[12],o=t.x*i[1]+t.y*i[5]+i[13];return r.x=s,r.y=o,r}static PointInTriangle(t,e,r,i){const s=.5*(-r.y*i.x+e.y*(-r.x+i.x)+e.x*(r.y-i.y)+r.x*i.y),o=s<0?-1:1,n=(e.y*i.x-e.x*i.y+(i.y-e.y)*t.x+(e.x-i.x)*t.y)*o,a=(e.x*r.y-e.y*r.x+(e.y-r.y)*t.x+(r.x-e.x)*t.y)*o;return n>0&&a>0&&n+a<2*s*o}static Distance(t,e){return Math.sqrt(c.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t.x-e.x,i=t.y-e.y;return r*r+i*i}static Center(t,e){return c.CenterToRef(t,e,new c)}static CenterToRef(t,e,r){return r.copyFromFloats((t.x+e.x)/2,(t.y+e.y)/2)}static DistanceOfPointFromSegment(t,e,r){const i=c.DistanceSquared(e,r);if(0===i)return c.Distance(t,e);const s=r.subtract(e),o=Math.max(0,Math.min(1,c.Dot(t.subtract(e),s)/i)),n=e.add(s.multiplyByFloats(o,o));return c.Distance(t,n)}}c._V8PerformanceHack=new c(.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[2]},rank:{value:1}});class y{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(t=0,e=0,r=0){this._isDirty=!0,this._x=t,this._y=e,this._z=r}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){let t=_(this._x);return t=397*t^_(this._y),t=397*t^_(this._z),t}asArray(){return[this._x,this._y,this._z]}toArray(t,e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,this}fromArray(t,e=0){return y.FromArrayToRef(t,e,this),this}toQuaternion(){return u.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._isDirty=!0,this}addInPlaceFromFloats(t,e,r){return this._x+=t,this._y+=e,this._z+=r,this._isDirty=!0,this}add(t){return new y(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,e){return e._x=this._x+t._x,e._y=this._y+t._y,e._z=this._z+t._z,e._isDirty=!0,e}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}subtract(t){return new y(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,e){return this.subtractFromFloatsToRef(t._x,t._y,t._z,e)}subtractFromFloats(t,e,r){return new y(this._x-t,this._y-e,this._z-r)}subtractFromFloatsToRef(t,e,r,i){return i._x=this._x-t,i._y=this._y-e,i._z=this._z-r,i._isDirty=!0,i}negate(){return new y(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t._x=-1*this._x,t._y=-1*this._y,t._z=-1*this._z,t._isDirty=!0,t}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new y(this._x*t,this._y*t,this._z*t)}scaleToRef(t,e){return e._x=this._x*t,e._y=this._y*t,e._z=this._z*t,e._isDirty=!0,e}getNormalToRef(t){const e=this.length();let r=Math.acos(this.y/e);const i=Math.atan2(this.z,this.x);r>Math.PI/2?r-=Math.PI/2:r+=Math.PI/2;const s=e*Math.sin(r)*Math.cos(i),o=e*Math.cos(r),n=e*Math.sin(r)*Math.sin(i);return t.set(s,o,n),t}applyRotationQuaternionToRef(t,e){const r=this._x,i=this._y,s=this._z,o=t._x,n=t._y,a=t._z,h=t._w,_=2*(n*s-a*i),c=2*(a*r-o*s),y=2*(o*i-n*r);return e._x=r+h*_+n*y-a*c,e._y=i+h*c+a*_-o*y,e._z=s+h*y+o*c-n*_,e._isDirty=!0,e}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new y)}scaleAndAddToRef(t,e){return e._x+=this._x*t,e._y+=this._y*t,e._z+=this._z*t,e._isDirty=!0,e}projectOnPlane(t,e){return this.projectOnPlaneToRef(t,e,new y)}projectOnPlaneToRef(t,e,r){const i=t.normal,s=t.d,o=x.Vector3[0];this.subtractToRef(e,o),o.normalize();const n=y.Dot(o,i);if(Math.abs(n)<1e-10)r.setAll(1/0);else{const t=-(y.Dot(e,i)+s)/n,a=o.scaleInPlace(t);e.addToRef(a,r)}return r}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t,e=i.bH){return t&&(0,h.WithinEpsilon)(this._x,t._x,e)&&(0,h.WithinEpsilon)(this._y,t._y,e)&&(0,h.WithinEpsilon)(this._z,t._z,e)}equalsToFloats(t,e,r){return this._x===t&&this._y===e&&this._z===r}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,e){return e._x=this._x*t._x,e._y=this._y*t._y,e._z=this._z*t._z,e._isDirty=!0,e}multiplyByFloats(t,e,r){return new y(this._x*t,this._y*e,this._z*r)}divide(t){return new y(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,e){return e._x=this._x/t._x,e._y=this._y/t._y,e._z=this._z/t._z,e._isDirty=!0,e}divideInPlace(t){return this._x=this._x/t._x,this._y=this._y/t._y,this._z=this._z/t._z,this._isDirty=!0,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,e,r){return t<this._x&&(this.x=t),e<this._y&&(this.y=e),r<this._z&&(this.z=r),this}maximizeInPlaceFromFloats(t,e,r){return t>this._x&&(this.x=t),e>this._y&&(this.y=e),r>this._z&&(this.z=r),this}isNonUniformWithinEpsilon(t){const e=Math.abs(this._x),r=Math.abs(this._y);if(!(0,h.WithinEpsilon)(e,r,t))return!0;const i=Math.abs(this._z);return!(0,h.WithinEpsilon)(e,i,t)||!(0,h.WithinEpsilon)(r,i,t)}get isNonUniform(){const t=Math.abs(this._x);return t!==Math.abs(this._y)||t!==Math.abs(this._z)}floorToRef(t){return t._x=Math.floor(this._x),t._y=Math.floor(this._y),t._z=Math.floor(this._z),t._isDirty=!0,t}floor(){return new y(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))}fractToRef(t){return t._x=this.x-Math.floor(this._x),t._y=this.y-Math.floor(this._y),t._z=this.z-Math.floor(this._z),t._isDirty=!0,t}fract(){return new y(this.x-Math.floor(this._x),this.y-Math.floor(this._y),this.z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z==0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){if("xyz"===(t=t.toLowerCase()))return this;const e=x.Vector3[0].copyFrom(this);return this.x=e[t[0]],this.y=e[t[1]],this.z=e[t[2]],this}rotateByQuaternionToRef(t,e){return t.toRotationMatrix(x.Matrix[0]),y.TransformCoordinatesToRef(this,x.Matrix[0],e),e}rotateByQuaternionAroundPointToRef(t,e,r){return this.subtractToRef(e,x.Vector3[0]),x.Vector3[0].rotateByQuaternionToRef(t,x.Vector3[0]),e.addToRef(x.Vector3[0],r),r}cross(t){return y.CrossToRef(this,t,new y)}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new y)}normalizeToRef(t){const e=this.length();return 0===e||1===e?(t._x=this._x,t._y=this._y,t._z=this._z,t._isDirty=!0,t):this.scaleToRef(1/e,t)}clone(){return new y(this._x,this._y,this._z)}copyFrom(t){return this.copyFromFloats(t._x,t._y,t._z)}copyFromFloats(t,e,r){return this._x=t,this._y=e,this._z=r,this._isDirty=!0,this}set(t,e,r){return this.copyFromFloats(t,e,r)}setAll(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,e,r,i){const s=y.Dot(t,r);return(s-i)/(s-y.Dot(e,r))}static GetAngleBetweenVectors(t,e,r){const i=t.normalizeToRef(x.Vector3[1]),s=e.normalizeToRef(x.Vector3[2]);let o=y.Dot(i,s);o=(0,h.Clamp)(o,-1,1);const n=Math.acos(o),a=x.Vector3[3];return y.CrossToRef(i,s,a),y.Dot(a,r)>0?isNaN(n)?0:n:isNaN(n)?-Math.PI:-Math.acos(o)}static GetAngleBetweenVectorsOnPlane(t,e,r){x.Vector3[0].copyFrom(t);const i=x.Vector3[0];x.Vector3[1].copyFrom(e);const s=x.Vector3[1];x.Vector3[2].copyFrom(r);const o=x.Vector3[2],n=x.Vector3[3],a=x.Vector3[4];i.normalize(),s.normalize(),o.normalize(),y.CrossToRef(o,i,n),y.CrossToRef(n,o,a);const _=Math.atan2(y.Dot(s,n),y.Dot(s,a));return(0,h.NormalizeRadians)(_)}static PitchYawRollToMoveBetweenPointsToRef(t,e,r){const i=f.Vector3[0];return e.subtractToRef(t,i),r._y=Math.atan2(i.x,i.z)||0,r._x=Math.atan2(Math.sqrt(i.x**2+i.z**2),i.y)||0,r._z=0,r._isDirty=!0,r}static PitchYawRollToMoveBetweenPoints(t,e){const r=y.Zero();return y.PitchYawRollToMoveBetweenPointsToRef(t,e,r)}static SlerpToRef(t,e,r,s){r=(0,h.Clamp)(r,0,1);const o=x.Vector3[0],n=x.Vector3[1];o.copyFrom(t);const a=o.length();o.normalizeFromLength(a),n.copyFrom(e);const _=n.length();n.normalizeFromLength(_);const c=y.Dot(o,n);let l,u;if(c<1-i.bH){const t=Math.acos(c),e=1/Math.sin(t);l=Math.sin((1-r)*t)*e,u=Math.sin(r*t)*e}else l=1-r,u=r;return o.scaleInPlace(l),n.scaleInPlace(u),s.copyFrom(o).addInPlace(n),s.scaleInPlace((0,h.Lerp)(a,_,r)),s}static SmoothToRef(t,e,r,i,s){return y.SlerpToRef(t,e,0===i?1:r/i,s),s}static FromArray(t,e=0){return new y(t[e],t[e+1],t[e+2])}static FromFloatArray(t,e){return y.FromArray(t,e)}static FromArrayToRef(t,e,r){return r._x=t[e],r._y=t[e+1],r._z=t[e+2],r._isDirty=!0,r}static FromFloatArrayToRef(t,e,r){return y.FromArrayToRef(t,e,r)}static FromFloatsToRef(t,e,r,i){return i.copyFromFloats(t,e,r),i}static Zero(){return new y(0,0,0)}static One(){return new y(1,1,1)}static Up(){return new y(0,1,0)}static get UpReadOnly(){return y._UpReadOnly}static get DownReadOnly(){return y._DownReadOnly}static get RightReadOnly(){return y._RightReadOnly}static get LeftReadOnly(){return y._LeftReadOnly}static get LeftHandedForwardReadOnly(){return y._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return y._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return y._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return y._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return y._ZeroReadOnly}static get OneReadOnly(){return y._OneReadOnly}static Down(){return new y(0,-1,0)}static Forward(t=!1){return new y(0,0,t?-1:1)}static Backward(t=!1){return new y(0,0,t?1:-1)}static Right(){return new y(1,0,0)}static Left(){return new y(-1,0,0)}static Random(t=0,e=1){return new y((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static RandomToRef(t=0,e=1,r){return r.copyFromFloats((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static TransformCoordinates(t,e){const r=y.Zero();return y.TransformCoordinatesToRef(t,e,r),r}static TransformCoordinatesToRef(t,e,r){return y.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformCoordinatesFromFloatsToRef(t,e,r,i,s){const o=i.m,n=t*o[0]+e*o[4]+r*o[8]+o[12],a=t*o[1]+e*o[5]+r*o[9]+o[13],h=t*o[2]+e*o[6]+r*o[10]+o[14],_=1/(t*o[3]+e*o[7]+r*o[11]+o[15]);return s._x=n*_,s._y=a*_,s._z=h*_,s._isDirty=!0,s}static TransformNormal(t,e){const r=y.Zero();return y.TransformNormalToRef(t,e,r),r}static TransformNormalToRef(t,e,r){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformNormalFromFloatsToRef(t,e,r,i,s){const o=i.m;return s._x=t*o[0]+e*o[4]+r*o[8],s._y=t*o[1]+e*o[5]+r*o[9],s._z=t*o[2]+e*o[6]+r*o[10],s._isDirty=!0,s}static CatmullRom(t,e,r,i,s){const o=s*s,n=s*o,a=.5*(2*e._x+(-t._x+r._x)*s+(2*t._x-5*e._x+4*r._x-i._x)*o+(-t._x+3*e._x-3*r._x+i._x)*n),h=.5*(2*e._y+(-t._y+r._y)*s+(2*t._y-5*e._y+4*r._y-i._y)*o+(-t._y+3*e._y-3*r._y+i._y)*n),_=.5*(2*e._z+(-t._z+r._z)*s+(2*t._z-5*e._z+4*r._z-i._z)*o+(-t._z+3*e._z-3*r._z+i._z)*n);return new y(a,h,_)}static Clamp(t,e,r){const i=new y;return y.ClampToRef(t,e,r,i),i}static ClampToRef(t,e,r,i){let s=t._x;s=s>r._x?r._x:s,s=s<e._x?e._x:s;let o=t._y;o=o>r._y?r._y:o,o=o<e._y?e._y:o;let n=t._z;return n=n>r._z?r._z:n,n=n<e._z?e._z:n,i.copyFromFloats(s,o,n),i}static CheckExtends(t,e,r){e.minimizeInPlace(t),r.maximizeInPlace(t)}static Hermite(t,e,r,i,s){const o=s*s,n=s*o,a=2*n-3*o+1,h=-2*n+3*o,_=n-2*o+s,c=n-o,l=t._x*a+r._x*h+e._x*_+i._x*c,u=t._y*a+r._y*h+e._y*_+i._y*c,m=t._z*a+r._z*h+e._z*_+i._z*c;return new y(l,u,m)}static Hermite1stDerivative(t,e,r,i,s){const o=new y;return this.Hermite1stDerivativeToRef(t,e,r,i,s,o),o}static Hermite1stDerivativeToRef(t,e,r,i,s,o){const n=s*s;return o._x=6*(n-s)*t._x+(3*n-4*s+1)*e._x+6*(-n+s)*r._x+(3*n-2*s)*i._x,o._y=6*(n-s)*t._y+(3*n-4*s+1)*e._y+6*(-n+s)*r._y+(3*n-2*s)*i._y,o._z=6*(n-s)*t._z+(3*n-4*s+1)*e._z+6*(-n+s)*r._z+(3*n-2*s)*i._z,o._isDirty=!0,o}static Lerp(t,e,r){const i=new y(0,0,0);return y.LerpToRef(t,e,r,i),i}static LerpToRef(t,e,r,i){return i._x=t._x+(e._x-t._x)*r,i._y=t._y+(e._y-t._y)*r,i._z=t._z+(e._z-t._z)*r,i._isDirty=!0,i}static Dot(t,e){return t._x*e._x+t._y*e._y+t._z*e._z}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}static Cross(t,e){const r=new y;return y.CrossToRef(t,e,r),r}static CrossToRef(t,e,r){const i=t._y*e._z-t._z*e._y,s=t._z*e._x-t._x*e._z,o=t._x*e._y-t._y*e._x;return r.copyFromFloats(i,s,o),r}static Normalize(t){const e=y.Zero();return y.NormalizeToRef(t,e),e}static NormalizeToRef(t,e){return t.normalizeToRef(e),e}static Project(t,e,r,i){const s=new y;return y.ProjectToRef(t,e,r,i,s),s}static ProjectToRef(t,e,r,i,s){const o=i.width,n=i.height,h=i.x,_=i.y,c=x.Matrix[1],l=a.q.LastCreatedEngine?.isNDCHalfZRange,u=l?1:.5,f=l?0:.5;m.FromValuesToRef(o/2,0,0,0,0,-n/2,0,0,0,0,u,0,h+o/2,n/2+_,f,1,c);const R=x.Matrix[0];return e.multiplyToRef(r,R),R.multiplyToRef(c,R),y.TransformCoordinatesToRef(t,R,s),s}static Reflect(t,e){return this.ReflectToRef(t,e,new y)}static ReflectToRef(t,e,r){const i=f.Vector3[0];return i.copyFrom(e).scaleInPlace(2*y.Dot(t,e)),r.copyFrom(t).subtractInPlace(i)}static _UnprojectFromInvertedMatrixToRef(t,e,r){y.TransformCoordinatesToRef(t,e,r);const i=e.m,s=t._x*i[3]+t._y*i[7]+t._z*i[11]+i[15];return(0,h.WithinEpsilon)(s,1)&&r.scaleInPlace(1/s),r}static UnprojectFromTransform(t,e,r,i,s){return this.Unproject(t,e,r,i,s,m.IdentityReadOnly)}static Unproject(t,e,r,i,s,o){const n=new y;return y.UnprojectToRef(t,e,r,i,s,o,n),n}static UnprojectToRef(t,e,r,i,s,o,n){return y.UnprojectFloatsToRef(t._x,t._y,t._z,e,r,i,s,o,n),n}static UnprojectFloatsToRef(t,e,r,i,s,o,n,h,_){const c=x.Matrix[0];o.multiplyToRef(n,c),c.multiplyToRef(h,c),c.invert();const l=x.Vector3[0];return l.x=t/i*2-1,l.y=-(e/s*2-1),a.q.LastCreatedEngine?.isNDCHalfZRange?l.z=r:l.z=2*r-1,y._UnprojectFromInvertedMatrixToRef(l,c,_),_}static Minimize(t,e){const r=new y;return r.copyFrom(t),r.minimizeInPlace(e),r}static Maximize(t,e){const r=new y;return r.copyFrom(t),r.maximizeInPlace(e),r}static Distance(t,e){return Math.sqrt(y.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t._x-e._x,i=t._y-e._y,s=t._z-e._z;return r*r+i*i+s*s}static ProjectOnTriangleToRef(t,e,r,s,o){const n=x.Vector3[0],a=x.Vector3[1],_=x.Vector3[2],c=x.Vector3[3],l=x.Vector3[4];r.subtractToRef(e,n),s.subtractToRef(e,a),s.subtractToRef(r,_);const u=n.length(),m=a.length(),f=_.length();if(u<i.bH||m<i.bH||f<i.bH)return o.copyFrom(e),y.Distance(t,e);t.subtractToRef(e,l),y.CrossToRef(n,a,c);const R=c.length();if(R<i.bH)return o.copyFrom(e),y.Distance(t,e);c.normalizeFromLength(R);let d=l.length();if(d<i.bH)return o.copyFrom(e),0;l.normalizeFromLength(d);const z=y.Dot(c,l),T=x.Vector3[5],w=x.Vector3[6];T.copyFrom(c).scaleInPlace(-d*z),w.copyFrom(t).addInPlace(T);const p=x.Vector3[4],F=x.Vector3[5],M=x.Vector3[7],I=x.Vector3[8];p.copyFrom(n).scaleInPlace(1/u),I.copyFrom(a).scaleInPlace(1/m),p.addInPlace(I).scaleInPlace(-1),F.copyFrom(n).scaleInPlace(-1/u),I.copyFrom(_).scaleInPlace(1/f),F.addInPlace(I).scaleInPlace(-1),M.copyFrom(_).scaleInPlace(-1/f),I.copyFrom(a).scaleInPlace(-1/m),M.addInPlace(I).scaleInPlace(-1);const g=x.Vector3[9];let P;g.copyFrom(w).subtractInPlace(e),y.CrossToRef(p,g,I),P=y.Dot(I,c);const D=P;g.copyFrom(w).subtractInPlace(r),y.CrossToRef(F,g,I),P=y.Dot(I,c);const A=P;g.copyFrom(w).subtractInPlace(s),y.CrossToRef(M,g,I),P=y.Dot(I,c);const C=P,V=x.Vector3[10];let v,H;D>0&&A<0?(V.copyFrom(n),v=e,H=r):A>0&&C<0?(V.copyFrom(_),v=r,H=s):(V.copyFrom(a).scaleInPlace(-1),v=s,H=e);const L=x.Vector3[9],k=x.Vector3[4];if(v.subtractToRef(w,I),H.subtractToRef(w,L),y.CrossToRef(I,L,k),!(y.Dot(k,c)<0))return o.copyFrom(w),Math.abs(d*z);const b=x.Vector3[5];y.CrossToRef(V,k,b),b.normalize();const O=x.Vector3[9];O.copyFrom(v).subtractInPlace(w);const U=O.length();if(U<i.bH)return o.copyFrom(v),y.Distance(t,v);O.normalizeFromLength(U);const q=y.Dot(b,O),S=x.Vector3[7];S.copyFrom(w).addInPlace(b.scaleInPlace(U*q)),I.copyFrom(S).subtractInPlace(v),d=V.length(),V.normalizeFromLength(d);let E=y.Dot(I,V)/Math.max(d,i.bH);return E=(0,h.Clamp)(E,0,1),S.copyFrom(v).addInPlace(V.scaleInPlace(E*d)),o.copyFrom(S),y.Distance(t,S)}static Center(t,e){return y.CenterToRef(t,e,y.Zero())}static CenterToRef(t,e,r){return r.copyFromFloats((t._x+e._x)/2,(t._y+e._y)/2,(t._z+e._z)/2)}static RotationFromAxis(t,e,r){const i=new y;return y.RotationFromAxisToRef(t,e,r,i),i}static RotationFromAxisToRef(t,e,r,i){const s=x.Quaternion[0];return u.RotationQuaternionFromAxisToRef(t,e,r,s),s.toEulerAnglesToRef(i),i}}y._V8PerformanceHack=new y(.5,.5,.5),y._UpReadOnly=y.Up(),y._DownReadOnly=y.Down(),y._LeftHandedForwardReadOnly=y.Forward(!1),y._RightHandedForwardReadOnly=y.Forward(!0),y._LeftHandedBackwardReadOnly=y.Backward(!1),y._RightHandedBackwardReadOnly=y.Backward(!0),y._RightReadOnly=y.Right(),y._LeftReadOnly=y.Left(),y._ZeroReadOnly=y.Zero(),y._OneReadOnly=y.One(),Object.defineProperties(y.prototype,{dimension:{value:[3]},rank:{value:1}});class l{constructor(t=0,e=0,r=0,i=0){this.x=t,this.y=e,this.z=r,this.w=i}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){let t=_(this.x);return t=397*t^_(this.y),t=397*t^_(this.z),t=397*t^_(this.w),t}asArray(){return[this.x,this.y,this.z,this.w]}toArray(t,e){return void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,this}fromArray(t,e=0){return l.FromArrayToRef(t,e,this),this}addInPlace(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addInPlaceFromFloats(t,e,r,i){return this.x+=t,this.y+=e,this.z+=r,this.w+=i,this}add(t){return new l(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}addToRef(t,e){return e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e.w=this.w+t.w,e}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subtract(t){return new l(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)}subtractToRef(t,e){return e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e.w=this.w-t.w,e}subtractFromFloats(t,e,r,i){return new l(this.x-t,this.y-e,this.z-r,this.w-i)}subtractFromFloatsToRef(t,e,r,i,s){return s.x=this.x-t,s.y=this.y-e,s.z=this.z-r,s.w=this.w-i,s}negate(){return new l(-this.x,-this.y,-this.z,-this.w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=-this.w,t}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new l(this.x*t,this.y*t,this.z*t,this.w*t)}scaleToRef(t,e){return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e.w=this.w*t,e}scaleAndAddToRef(t,e){return e.x+=this.x*t,e.y+=this.y*t,e.z+=this.z*t,e.w+=this.w*t,e}equals(t){return t&&this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}equalsWithEpsilon(t,e=i.bH){return t&&(0,h.WithinEpsilon)(this.x,t.x,e)&&(0,h.WithinEpsilon)(this.y,t.y,e)&&(0,h.WithinEpsilon)(this.z,t.z,e)&&(0,h.WithinEpsilon)(this.w,t.w,e)}equalsToFloats(t,e,r,i){return this.x===t&&this.y===e&&this.z===r&&this.w===i}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new l(this.x*t.x,this.y*t.y,this.z*t.z,this.w*t.w)}multiplyToRef(t,e){return e.x=this.x*t.x,e.y=this.y*t.y,e.z=this.z*t.z,e.w=this.w*t.w,e}multiplyByFloats(t,e,r,i){return new l(this.x*t,this.y*e,this.z*r,this.w*i)}divide(t){return new l(this.x/t.x,this.y/t.y,this.z/t.z,this.w/t.w)}divideToRef(t,e){return e.x=this.x/t.x,e.y=this.y/t.y,e.z=this.z/t.z,e.w=this.w/t.w,e}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),t.w<this.w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),t.w>this.w&&(this.w=t.w),this}minimizeInPlaceFromFloats(t,e,r,i){return this.x=Math.min(t,this.x),this.y=Math.min(e,this.y),this.z=Math.min(r,this.z),this.w=Math.min(i,this.w),this}maximizeInPlaceFromFloats(t,e,r,i){return this.x=Math.max(t,this.x),this.y=Math.max(e,this.y),this.z=Math.max(r,this.z),this.w=Math.max(i,this.w),this}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t.z=Math.floor(this.z),t.w=Math.floor(this.w),t}floor(){return new l(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t.z=this.z-Math.floor(this.z),t.w=this.w-Math.floor(this.w),t}fract(){return new l(this.x-Math.floor(this.x),this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new l)}normalizeToRef(t){const e=this.length();return 0===e||1===e?(t.x=this.x,t.y=this.y,t.z=this.z,t.w=this.w,t):this.scaleToRef(1/e,t)}toVector3(){return new y(this.x,this.y,this.z)}clone(){return new l(this.x,this.y,this.z,this.w)}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}copyFromFloats(t,e,r,i){return this.x=t,this.y=e,this.z=r,this.w=i,this}set(t,e,r,i){return this.copyFromFloats(t,e,r,i)}setAll(t){return this.x=this.y=this.z=this.w=t,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}static FromArray(t,e){return e||(e=0),new l(t[e],t[e+1],t[e+2],t[e+3])}static FromArrayToRef(t,e,r){return r.x=t[e],r.y=t[e+1],r.z=t[e+2],r.w=t[e+3],r}static FromFloatArrayToRef(t,e,r){return l.FromArrayToRef(t,e,r),r}static FromFloatsToRef(t,e,r,i,s){return s.x=t,s.y=e,s.z=r,s.w=i,s}static Zero(){return new l(0,0,0,0)}static One(){return new l(1,1,1,1)}static Random(t=0,e=1){return new l((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static RandomToRef(t=0,e=1,r){return r.x=(0,h.RandomRange)(t,e),r.y=(0,h.RandomRange)(t,e),r.z=(0,h.RandomRange)(t,e),r.w=(0,h.RandomRange)(t,e),r}static Clamp(t,e,r){return l.ClampToRef(t,e,r,new l)}static ClampToRef(t,e,r,i){return i.x=(0,h.Clamp)(t.x,e.x,r.x),i.y=(0,h.Clamp)(t.y,e.y,r.y),i.z=(0,h.Clamp)(t.z,e.z,r.z),i.w=(0,h.Clamp)(t.w,e.w,r.w),i}static CheckExtends(t,e,r){e.minimizeInPlace(t),r.maximizeInPlace(t)}static get ZeroReadOnly(){return l._ZeroReadOnly}static Normalize(t){return l.NormalizeToRef(t,new l)}static NormalizeToRef(t,e){return t.normalizeToRef(e),e}static Minimize(t,e){const r=new l;return r.copyFrom(t),r.minimizeInPlace(e),r}static Maximize(t,e){const r=new l;return r.copyFrom(t),r.maximizeInPlace(e),r}static Distance(t,e){return Math.sqrt(l.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t.x-e.x,i=t.y-e.y,s=t.z-e.z,o=t.w-e.w;return r*r+i*i+s*s+o*o}static Center(t,e){return l.CenterToRef(t,e,new l)}static CenterToRef(t,e,r){return r.x=(t.x+e.x)/2,r.y=(t.y+e.y)/2,r.z=(t.z+e.z)/2,r.w=(t.w+e.w)/2,r}static TransformCoordinates(t,e){return l.TransformCoordinatesToRef(t,e,new l)}static TransformCoordinatesToRef(t,e,r){return l.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformCoordinatesFromFloatsToRef(t,e,r,i,s){const o=i.m,n=t*o[0]+e*o[4]+r*o[8]+o[12],a=t*o[1]+e*o[5]+r*o[9]+o[13],h=t*o[2]+e*o[6]+r*o[10]+o[14],_=t*o[3]+e*o[7]+r*o[11]+o[15];return s.x=n,s.y=a,s.z=h,s.w=_,s}static TransformNormal(t,e){return l.TransformNormalToRef(t,e,new l)}static TransformNormalToRef(t,e,r){const i=e.m,s=t.x*i[0]+t.y*i[4]+t.z*i[8],o=t.x*i[1]+t.y*i[5]+t.z*i[9],n=t.x*i[2]+t.y*i[6]+t.z*i[10];return r.x=s,r.y=o,r.z=n,r.w=t.w,r}static TransformNormalFromFloatsToRef(t,e,r,i,s,o){const n=s.m;return o.x=t*n[0]+e*n[4]+r*n[8],o.y=t*n[1]+e*n[5]+r*n[9],o.z=t*n[2]+e*n[6]+r*n[10],o.w=i,o}static FromVector3(t,e=0){return new l(t._x,t._y,t._z,e)}static Dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z+t.w*e.w}}l._V8PerformanceHack=new l(.5,.5,.5,.5),l._ZeroReadOnly=l.Zero(),Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class u{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(t=0,e=0,r=0,i=1){this._isDirty=!0,this._x=t,this._y=e,this._z=r,this._w=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let t=_(this._x);return t=397*t^_(this._y),t=397*t^_(this._z),t=397*t^_(this._w),t}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t,e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,this}fromArray(t,e=0){return u.FromArrayToRef(t,e,this)}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t,e=i.bH){return t&&(0,h.WithinEpsilon)(this._x,t._x,e)&&(0,h.WithinEpsilon)(this._y,t._y,e)&&(0,h.WithinEpsilon)(this._z,t._z,e)&&(0,h.WithinEpsilon)(this._w,t._w,e)}clone(){return new u(this._x,this._y,this._z,this._w)}copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}copyFromFloats(t,e,r,i){return this._x=t,this._y=e,this._z=r,this._w=i,this._isDirty=!0,this}set(t,e,r,i){return this.copyFromFloats(t,e,r,i)}setAll(t){return this.copyFromFloats(t,t,t,t)}add(t){return new u(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}addToRef(t,e){return e._x=this._x+t._x,e._y=this._y+t._y,e._z=this._z+t._z,e._w=this._w+t._w,e._isDirty=!0,e}addInPlaceFromFloats(t,e,r,i){return this._x+=t,this._y+=e,this._z+=r,this._w+=i,this._isDirty=!0,this}subtractToRef(t,e){return e._x=this._x-t._x,e._y=this._y-t._y,e._z=this._z-t._z,e._w=this._w-t._w,e._isDirty=!0,e}subtractFromFloats(t,e,r,i){return this.subtractFromFloatsToRef(t,e,r,i,new u)}subtractFromFloatsToRef(t,e,r,i,s){return s._x=this._x-t,s._y=this._y-e,s._z=this._z-r,s._w=this._w-i,s._isDirty=!0,s}subtract(t){return new u(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new u(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,e){return e._x=this._x*t,e._y=this._y*t,e._z=this._z*t,e._w=this._w*t,e._isDirty=!0,e}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,e){return e._x+=this._x*t,e._y+=this._y*t,e._z+=this._z*t,e._w+=this._w*t,e._isDirty=!0,e}multiply(t){const e=new u(0,0,0,1);return this.multiplyToRef(t,e),e}multiplyToRef(t,e){const r=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,i=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,s=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,o=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return e.copyFromFloats(r,i,s,o),e}multiplyInPlace(t){return this.multiplyToRef(t,this)}multiplyByFloats(t,e,r,i){return this._x*=t,this._y*=e,this._z*=r,this._w*=i,this._isDirty=!0,this}divide(t){throw new ReferenceError("Can not divide a quaternion")}divideToRef(t,e){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(t){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new u)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(t){return t._x=-this._x,t._y=-this._y,t._z=-this._z,t._w=-this._w,t._isDirty=!0,t}equalsToFloats(t,e,r,i){return this._x===t&&this._y===e&&this._z===r&&this._w===i}floorToRef(t){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(t){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(t){return t.copyFromFloats(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new u(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),e=this.lengthSquared();return 0==e||1==e||t.scaleInPlace(1/e),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return 0==t||1==t||this.scaleInPlace(1/t),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new u(0,0,0,1);return this.normalizeToRef(t),t}normalizeToRef(t){const e=this.length();return 0===e||1===e?t.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/e,t)}toEulerAngles(){const t=y.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const e=this._z,r=this._x,i=this._y,s=this._w,o=i*e-r*s,n=.4999999;if(o<-n)t._y=2*Math.atan2(i,s),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(o>n)t._y=2*Math.atan2(i,s),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const n=s*s,a=e*e,h=r*r,_=i*i;t._z=Math.atan2(2*(r*i+e*s),-a-h+_+n),t._x=Math.asin(-2*o),t._y=Math.atan2(2*(e*r+i*s),a-h-_+n),t._isDirty=!0}return t}toAlphaBetaGammaToRef(t){const e=this._z,r=this._x,i=this._y,s=this._w,o=Math.sqrt(r*r+i*i),n=Math.sqrt(e*e+s*s),a=2*Math.atan2(o,n),h=2*Math.atan2(e,s),_=2*Math.atan2(i,r),c=(h+_)/2,y=(h-_)/2;return t.set(y,a,c),t}toRotationMatrix(t){return m.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return u.FromRotationMatrixToRef(t,this),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}static FromRotationMatrix(t){const e=new u;return u.FromRotationMatrixToRef(t,e),e}static FromRotationMatrixToRef(t,e){const r=t.m,i=r[0],s=r[4],o=r[8],n=r[1],a=r[5],h=r[9],_=r[2],c=r[6],y=r[10],l=i+a+y;let u;return l>0?(u=.5/Math.sqrt(l+1),e._w=.25/u,e._x=(c-h)*u,e._y=(o-_)*u,e._z=(n-s)*u,e._isDirty=!0):i>a&&i>y?(u=2*Math.sqrt(1+i-a-y),e._w=(c-h)/u,e._x=.25*u,e._y=(s+n)/u,e._z=(o+_)/u,e._isDirty=!0):a>y?(u=2*Math.sqrt(1+a-i-y),e._w=(o-_)/u,e._x=(s+n)/u,e._y=.25*u,e._z=(h+c)/u,e._isDirty=!0):(u=2*Math.sqrt(1+y-i-a),e._w=(n-s)/u,e._x=(o+_)/u,e._y=(h+c)/u,e._z=.25*u,e._isDirty=!0),e}static Dot(t,e){return t._x*e._x+t._y*e._y+t._z*e._z+t._w*e._w}static AreClose(t,e,r=.1){const i=u.Dot(t,e);return 1-i*i<=r}static SmoothToRef(t,e,r,i,s){let o=0===i?1:r/i;return o=(0,h.Clamp)(o,0,1),u.SlerpToRef(t,e,o,s),s}static Zero(){return new u(0,0,0,0)}static Inverse(t){return new u(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,e){return e.set(-t._x,-t._y,-t._z,t._w),e}static Identity(){return new u(0,0,0,1)}static IsIdentity(t){return t&&0===t._x&&0===t._y&&0===t._z&&1===t._w}static RotationAxis(t,e){return u.RotationAxisToRef(t,e,new u)}static RotationAxisToRef(t,e,r){r._w=Math.cos(e/2);const i=Math.sin(e/2)/t.length();return r._x=t._x*i,r._y=t._y*i,r._z=t._z*i,r._isDirty=!0,r}static FromArray(t,e){return e||(e=0),new u(t[e],t[e+1],t[e+2],t[e+3])}static FromArrayToRef(t,e,r){return r._x=t[e],r._y=t[e+1],r._z=t[e+2],r._w=t[e+3],r._isDirty=!0,r}static FromFloatsToRef(t,e,r,i,s){return s.copyFromFloats(t,e,r,i),s}static FromEulerAngles(t,e,r){const i=new u;return u.RotationYawPitchRollToRef(e,t,r,i),i}static FromEulerAnglesToRef(t,e,r,i){return u.RotationYawPitchRollToRef(e,t,r,i),i}static FromEulerVector(t){const e=new u;return u.RotationYawPitchRollToRef(t._y,t._x,t._z,e),e}static FromEulerVectorToRef(t,e){return u.RotationYawPitchRollToRef(t._y,t._x,t._z,e),e}static FromUnitVectorsToRef(t,e,r,s=i.bH){const o=y.Dot(t,e)+1;return o<s?Math.abs(t.x)>Math.abs(t.z)?r.set(-t.y,t.x,0,0):r.set(0,-t.z,t.y,0):(y.CrossToRef(t,e,f.Vector3[0]),r.set(f.Vector3[0].x,f.Vector3[0].y,f.Vector3[0].z,o)),r.normalize()}static RotationYawPitchRoll(t,e,r){const i=new u;return u.RotationYawPitchRollToRef(t,e,r,i),i}static RotationYawPitchRollToRef(t,e,r,i){const s=.5*r,o=.5*e,n=.5*t,a=Math.sin(s),h=Math.cos(s),_=Math.sin(o),c=Math.cos(o),y=Math.sin(n),l=Math.cos(n);return i._x=l*_*h+y*c*a,i._y=y*c*h-l*_*a,i._z=l*c*a-y*_*h,i._w=l*c*h+y*_*a,i._isDirty=!0,i}static RotationAlphaBetaGamma(t,e,r){const i=new u;return u.RotationAlphaBetaGammaToRef(t,e,r,i),i}static RotationAlphaBetaGammaToRef(t,e,r,i){const s=.5*(r+t),o=.5*(r-t),n=.5*e;return i._x=Math.cos(o)*Math.sin(n),i._y=Math.sin(o)*Math.sin(n),i._z=Math.sin(s)*Math.cos(n),i._w=Math.cos(s)*Math.cos(n),i._isDirty=!0,i}static RotationQuaternionFromAxis(t,e,r){const i=new u(0,0,0,0);return u.RotationQuaternionFromAxisToRef(t,e,r,i),i}static RotationQuaternionFromAxisToRef(t,e,r,i){const s=x.Matrix[0];return t=t.normalizeToRef(x.Vector3[0]),e=e.normalizeToRef(x.Vector3[1]),r=r.normalizeToRef(x.Vector3[2]),m.FromXYZAxesToRef(t,e,r,s),u.FromRotationMatrixToRef(s,i),i}static FromLookDirectionLH(t,e){const r=new u;return u.FromLookDirectionLHToRef(t,e,r),r}static FromLookDirectionLHToRef(t,e,r){const i=x.Matrix[0];return m.LookDirectionLHToRef(t,e,i),u.FromRotationMatrixToRef(i,r),r}static FromLookDirectionRH(t,e){const r=new u;return u.FromLookDirectionRHToRef(t,e,r),r}static FromLookDirectionRHToRef(t,e,r){const i=x.Matrix[0];return m.LookDirectionRHToRef(t,e,i),u.FromRotationMatrixToRef(i,r)}static Slerp(t,e,r){const i=u.Identity();return u.SlerpToRef(t,e,r,i),i}static SlerpToRef(t,e,r,i){let s,o,n=t._x*e._x+t._y*e._y+t._z*e._z+t._w*e._w,a=!1;if(n<0&&(a=!0,n=-n),n>.999999)o=1-r,s=a?-r:r;else{const t=Math.acos(n),e=1/Math.sin(t);o=Math.sin((1-r)*t)*e,s=a?-Math.sin(r*t)*e:Math.sin(r*t)*e}return i._x=o*t._x+s*e._x,i._y=o*t._y+s*e._y,i._z=o*t._z+s*e._z,i._w=o*t._w+s*e._w,i._isDirty=!0,i}static Hermite(t,e,r,i,s){const o=s*s,n=s*o,a=2*n-3*o+1,h=-2*n+3*o,_=n-2*o+s,c=n-o,y=t._x*a+r._x*h+e._x*_+i._x*c,l=t._y*a+r._y*h+e._y*_+i._y*c,m=t._z*a+r._z*h+e._z*_+i._z*c,x=t._w*a+r._w*h+e._w*_+i._w*c;return new u(y,l,m,x)}static Hermite1stDerivative(t,e,r,i,s){const o=new u;return this.Hermite1stDerivativeToRef(t,e,r,i,s,o),o}static Hermite1stDerivativeToRef(t,e,r,i,s,o){const n=s*s;return o._x=6*(n-s)*t._x+(3*n-4*s+1)*e._x+6*(-n+s)*r._x+(3*n-2*s)*i._x,o._y=6*(n-s)*t._y+(3*n-4*s+1)*e._y+6*(-n+s)*r._y+(3*n-2*s)*i._y,o._z=6*(n-s)*t._z+(3*n-4*s+1)*e._z+6*(-n+s)*r._z+(3*n-2*s)*i._z,o._w=6*(n-s)*t._w+(3*n-4*s+1)*e._w+6*(-n+s)*r._w+(3*n-2*s)*i._w,o._isDirty=!0,o}static Normalize(t){const e=u.Zero();return u.NormalizeToRef(t,e),e}static NormalizeToRef(t,e){return t.normalizeToRef(e),e}static Clamp(t,e,r){const i=new u;return u.ClampToRef(t,e,r,i),i}static ClampToRef(t,e,r,i){return i.copyFromFloats((0,h.Clamp)(t.x,e.x,r.x),(0,h.Clamp)(t.y,e.y,r.y),(0,h.Clamp)(t.z,e.z,r.z),(0,h.Clamp)(t.w,e.w,r.w))}static Random(t=0,e=1){return new u((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static RandomToRef(t=0,e=1,r){return r.copyFromFloats((0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e),(0,h.RandomRange)(t,e))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(t,e){return Math.sqrt(u.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t.x-e.x,i=t.y-e.y,s=t.z-e.z,o=t.w-e.w;return r*r+i*i+s*s+o*o}static Center(t,e){return u.CenterToRef(t,e,u.Zero())}static CenterToRef(t,e,r){return r.copyFromFloats((t.x+e.x)/2,(t.y+e.y)/2,(t.z+e.z)/2,(t.w+e.w)/2)}}u._V8PerformanceHack=new u(.5,.5,.5,.5),Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class m{static get Use64Bits(){return n.I.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=m._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t,e=!1,r=!1,i=!0){this._isIdentity=t,this._isIdentity3x2=t||r,this._isIdentityDirty=!this._isIdentity&&e,this._isIdentity3x2Dirty=!this._isIdentity3x2&&i}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,n.I.MatrixTrackPrecisionChange&&n.I.MatrixTrackedMatrices.push(this),this._m=new n.I.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this._m;this._isIdentity=1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&1===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&1===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this._m[0]||1!==this._m[5]||1!==this._m[15]||0!==this._m[1]||0!==this._m[2]||0!==this._m[3]||0!==this._m[4]||0!==this._m[6]||0!==this._m[7]||0!==this._m[8]||0!==this._m[9]||0!==this._m[10]||0!==this._m[11]||0!==this._m[12]||0!==this._m[13]||0!==this._m[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const t=this._m,e=t[0],r=t[1],i=t[2],s=t[3],o=t[4],n=t[5],a=t[6],h=t[7],_=t[8],c=t[9],y=t[10],l=t[11],u=t[12],m=t[13],x=t[14],f=t[15],R=y*f-x*l,d=c*f-m*l,z=c*x-m*y,T=_*f-u*l,w=_*x-y*u,p=_*m-u*c;return e*+(n*R-a*d+h*z)+r*-(o*R-a*T+h*w)+i*+(o*d-n*T+h*p)+s*-(o*z-n*w+a*p)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(t=null,e=0){if(!t)return this._m;const r=this._m;for(let i=0;i<16;i++)t[e+i]=r[i];return this}asArray(){return this._m}fromArray(t,e=0){return m.FromArrayToRef(t,e,this)}copyFromFloats(...t){return m.FromArrayToRef(t,0,this)}set(...t){const e=this._m;for(let r=0;r<16;r++)e[r]=t[r];return this.markAsUpdated(),this}setAll(t){const e=this._m;for(let r=0;r<16;r++)e[r]=t;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return m.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const e=new m;return this.addToRef(t,e),e}addToRef(t,e){const r=this._m,i=e._m,s=t.m;for(let t=0;t<16;t++)i[t]=r[t]+s[t];return e.markAsUpdated(),e}addToSelf(t){const e=this._m,r=t.m;return e[0]+=r[0],e[1]+=r[1],e[2]+=r[2],e[3]+=r[3],e[4]+=r[4],e[5]+=r[5],e[6]+=r[6],e[7]+=r[7],e[8]+=r[8],e[9]+=r[9],e[10]+=r[10],e[11]+=r[11],e[12]+=r[12],e[13]+=r[13],e[14]+=r[14],e[15]+=r[15],this.markAsUpdated(),this}addInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]+=r[t];return this.markAsUpdated(),this}addInPlaceFromFloats(...t){const e=this._m;for(let r=0;r<16;r++)e[r]+=t[r];return this.markAsUpdated(),this}subtract(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]-=r[t];return this.markAsUpdated(),this}subtractToRef(t,e){const r=this._m,i=t.m,s=e._m;for(let t=0;t<16;t++)s[t]=r[t]-i[t];return e.markAsUpdated(),e}subtractInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]-=r[t];return this.markAsUpdated(),this}subtractFromFloats(...t){return this.subtractFromFloatsToRef(...t,new m)}subtractFromFloatsToRef(...t){const e=t.pop(),r=this._m,i=e._m,s=t;for(let t=0;t<16;t++)i[t]=r[t]-s[t];return e.markAsUpdated(),e}invertToRef(t){if(!0===this._isIdentity)return m.IdentityToRef(t),t;const e=this._m,r=e[0],i=e[1],s=e[2],o=e[3],n=e[4],a=e[5],h=e[6],_=e[7],c=e[8],y=e[9],l=e[10],u=e[11],x=e[12],f=e[13],R=e[14],d=e[15],z=l*d-R*u,T=y*d-f*u,w=y*R-f*l,p=c*d-x*u,F=c*R-l*x,M=c*f-x*y,I=+(a*z-h*T+_*w),g=-(n*z-h*p+_*F),P=+(n*T-a*p+_*M),D=-(n*w-a*F+h*M),A=r*I+i*g+s*P+o*D;if(0===A)return t.copyFrom(this),t;const C=1/A,V=h*d-R*_,v=a*d-f*_,H=a*R-f*h,L=n*d-x*_,k=n*R-x*h,b=n*f-x*a,O=h*u-l*_,U=a*u-y*_,q=a*l-y*h,S=n*u-c*_,E=n*l-c*h,N=n*y-c*a,Z=-(i*z-s*T+o*w),B=+(r*z-s*p+o*F),Y=-(r*T-i*p+o*M),j=+(r*w-i*F+s*M),Q=+(i*V-s*v+o*H),W=-(r*V-s*L+o*k),$=+(r*v-i*L+o*b),G=-(r*H-i*k+s*b),X=-(i*O-s*U+o*q),J=+(r*O-s*S+o*E),K=-(r*U-i*S+o*N),tt=+(r*q-i*E+s*N);return m.FromValuesToRef(I*C,Z*C,Q*C,X*C,g*C,B*C,W*C,J*C,P*C,Y*C,$*C,K*C,D*C,j*C,G*C,tt*C,t),t}addAtIndex(t,e){return this._m[t]+=e,this.markAsUpdated(),this}multiplyAtIndex(t,e){return this._m[t]*=e,this.markAsUpdated(),this}setTranslationFromFloats(t,e,r){return this._m[12]=t,this._m[13]=e,this._m[14]=r,this.markAsUpdated(),this}addTranslationFromFloats(t,e,r){return this._m[12]+=t,this._m[13]+=e,this._m[14]+=r,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new y(this._m[12],this._m[13],this._m[14])}getTranslationToRef(t){return t.x=this._m[12],t.y=this._m[13],t.z=this._m[14],t}removeRotationAndScaling(){const t=this.m;return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]),this}copyFrom(t){t.copyToArray(this._m);const e=t;return this.updateFlag=e.updateFlag,this._updateIdentityStatus(e._isIdentity,e._isIdentityDirty,e._isIdentity3x2,e._isIdentity3x2Dirty),this}copyToArray(t,e=0){const r=this._m;return t[e]=r[0],t[e+1]=r[1],t[e+2]=r[2],t[e+3]=r[3],t[e+4]=r[4],t[e+5]=r[5],t[e+6]=r[6],t[e+7]=r[7],t[e+8]=r[8],t[e+9]=r[9],t[e+10]=r[10],t[e+11]=r[11],t[e+12]=r[12],t[e+13]=r[13],t[e+14]=r[14],t[e+15]=r[15],this}multiply(t){const e=new m;return this.multiplyToRef(t,e),e}multiplyInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]*=r[t];return this.markAsUpdated(),this}multiplyByFloats(...t){const e=this._m;for(let r=0;r<16;r++)e[r]*=t[r];return this.markAsUpdated(),this}multiplyByFloatsToRef(...t){const e=t.pop(),r=this._m,i=e._m,s=t;for(let t=0;t<16;t++)i[t]=r[t]*s[t];return e.markAsUpdated(),e}multiplyToRef(t,e){return this._isIdentity?(e.copyFrom(t),e):t._isIdentity?(e.copyFrom(this),e):(this.multiplyToArray(t,e._m,0),e.markAsUpdated(),e)}multiplyToArray(t,e,r){const i=this._m,s=t.m,o=i[0],n=i[1],a=i[2],h=i[3],_=i[4],c=i[5],y=i[6],l=i[7],u=i[8],m=i[9],x=i[10],f=i[11],R=i[12],d=i[13],z=i[14],T=i[15],w=s[0],p=s[1],F=s[2],M=s[3],I=s[4],g=s[5],P=s[6],D=s[7],A=s[8],C=s[9],V=s[10],v=s[11],H=s[12],L=s[13],k=s[14],b=s[15];return e[r]=o*w+n*I+a*A+h*H,e[r+1]=o*p+n*g+a*C+h*L,e[r+2]=o*F+n*P+a*V+h*k,e[r+3]=o*M+n*D+a*v+h*b,e[r+4]=_*w+c*I+y*A+l*H,e[r+5]=_*p+c*g+y*C+l*L,e[r+6]=_*F+c*P+y*V+l*k,e[r+7]=_*M+c*D+y*v+l*b,e[r+8]=u*w+m*I+x*A+f*H,e[r+9]=u*p+m*g+x*C+f*L,e[r+10]=u*F+m*P+x*V+f*k,e[r+11]=u*M+m*D+x*v+f*b,e[r+12]=R*w+d*I+z*A+T*H,e[r+13]=R*p+d*g+z*C+T*L,e[r+14]=R*F+d*P+z*V+T*k,e[r+15]=R*M+d*D+z*v+T*b,this}divide(t){return this.divideToRef(t,new m)}divideToRef(t,e){const r=this._m,i=t.m,s=e._m;for(let t=0;t<16;t++)s[t]=r[t]/i[t];return e.markAsUpdated(),e}divideInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]/=r[t];return this.markAsUpdated(),this}minimizeInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]=Math.min(e[t],r[t]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(...t){const e=this._m;for(let r=0;r<16;r++)e[r]=Math.min(e[r],t[r]);return this.markAsUpdated(),this}maximizeInPlace(t){const e=this._m,r=t.m;for(let t=0;t<16;t++)e[t]=Math.min(e[t],r[t]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(...t){const e=this._m;for(let r=0;r<16;r++)e[r]=Math.min(e[r],t[r]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new m)}negateInPlace(){const t=this._m;for(let e=0;e<16;e++)t[e]=-t[e];return this.markAsUpdated(),this}negateToRef(t){const e=this._m,r=t._m;for(let t=0;t<16;t++)r[t]=-e[t];return t.markAsUpdated(),t}equals(t){const e=t;if(!e)return!1;if((this._isIdentity||e._isIdentity)&&!this._isIdentityDirty&&!e._isIdentityDirty)return this._isIdentity&&e._isIdentity;const r=this.m,i=e.m;return r[0]===i[0]&&r[1]===i[1]&&r[2]===i[2]&&r[3]===i[3]&&r[4]===i[4]&&r[5]===i[5]&&r[6]===i[6]&&r[7]===i[7]&&r[8]===i[8]&&r[9]===i[9]&&r[10]===i[10]&&r[11]===i[11]&&r[12]===i[12]&&r[13]===i[13]&&r[14]===i[14]&&r[15]===i[15]}equalsWithEpsilon(t,e=0){const r=this._m,i=t.m;for(let t=0;t<16;t++)if(!(0,h.WithinEpsilon)(r[t],i[t],e))return!1;return!0}equalsToFloats(...t){const e=this._m;for(let r=0;r<16;r++)if(e[r]!=t[r])return!1;return!0}floor(){return this.floorToRef(new m)}floorToRef(t){const e=this._m,r=t._m;for(let t=0;t<16;t++)r[t]=Math.floor(e[t]);return t.markAsUpdated(),t}fract(){return this.fractToRef(new m)}fractToRef(t){const e=this._m,r=t._m;for(let t=0;t<16;t++)r[t]=e[t]-Math.floor(e[t]);return t.markAsUpdated(),t}clone(){const t=new m;return t.copyFrom(this),t}getClassName(){return"Matrix"}getHashCode(){let t=_(this._m[0]);for(let e=1;e<16;e++)t=397*t^_(this._m[e]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new u,this.decompose(t.scaling,t.rotationQuaternion,t.position)}decompose(t,e,r,i,s=!0){if(this._isIdentity)return r&&r.setAll(0),t&&t.setAll(1),e&&e.copyFromFloats(0,0,0,1),!0;const o=this._m;if(r&&r.copyFromFloats(o[12],o[13],o[14]),(t=t||x.Vector3[0]).x=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]),t.y=Math.sqrt(o[4]*o[4]+o[5]*o[5]+o[6]*o[6]),t.z=Math.sqrt(o[8]*o[8]+o[9]*o[9]+o[10]*o[10]),i){const e=(s?i.absoluteScaling.x:i.scaling.x)<0?-1:1,r=(s?i.absoluteScaling.y:i.scaling.y)<0?-1:1,o=(s?i.absoluteScaling.z:i.scaling.z)<0?-1:1;t.x*=e,t.y*=r,t.z*=o}else this.determinant()<=0&&(t.y*=-1);if(0===t._x||0===t._y||0===t._z)return e&&e.copyFromFloats(0,0,0,1),!1;if(e){const r=1/t._x,i=1/t._y,s=1/t._z;m.FromValuesToRef(o[0]*r,o[1]*r,o[2]*r,0,o[4]*i,o[5]*i,o[6]*i,0,o[8]*s,o[9]*s,o[10]*s,0,0,0,0,1,x.Matrix[0]),u.FromRotationMatrixToRef(x.Matrix[0],e)}return!0}getRow(t){if(t<0||t>3)return null;const e=4*t;return new l(this._m[e+0],this._m[e+1],this._m[e+2],this._m[e+3])}getRowToRef(t,e){if(t>=0&&t<=3){const r=4*t;e.x=this._m[r+0],e.y=this._m[r+1],e.z=this._m[r+2],e.w=this._m[r+3]}return e}setRow(t,e){return this.setRowFromFloats(t,e.x,e.y,e.z,e.w)}transpose(){const t=new m;return m.TransposeToRef(this,t),t}transposeToRef(t){return m.TransposeToRef(this,t),t}setRowFromFloats(t,e,r,i,s){if(t<0||t>3)return this;const o=4*t;return this._m[o+0]=e,this._m[o+1]=r,this._m[o+2]=i,this._m[o+3]=s,this.markAsUpdated(),this}scale(t){const e=new m;return this.scaleToRef(t,e),e}scaleToRef(t,e){for(let r=0;r<16;r++)e._m[r]=this._m[r]*t;return e.markAsUpdated(),e}scaleAndAddToRef(t,e){for(let r=0;r<16;r++)e._m[r]+=this._m[r]*t;return e.markAsUpdated(),e}scaleInPlace(t){const e=this._m;for(let r=0;r<16;r++)e[r]*=t;return this.markAsUpdated(),this}toNormalMatrix(t){const e=x.Matrix[0];this.invertToRef(e),e.transposeToRef(t);const r=t._m;return m.FromValuesToRef(r[0],r[1],r[2],0,r[4],r[5],r[6],0,r[8],r[9],r[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new m;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const e=x.Vector3[0];if(!this.decompose(e))return m.IdentityToRef(t),t;const r=this._m,i=1/e._x,s=1/e._y,o=1/e._z;return m.FromValuesToRef(r[0]*i,r[1]*i,r[2]*i,0,r[4]*s,r[5]*s,r[6]*s,0,r[8]*o,r[9]*o,r[10]*o,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this._m;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this._m;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static FromArray(t,e=0){const r=new m;return m.FromArrayToRef(t,e,r),r}static FromArrayToRef(t,e,r){for(let i=0;i<16;i++)r._m[i]=t[i+e];return r.markAsUpdated(),r}static FromFloat32ArrayToRefScaled(t,e,r,i){return i._m[0]=t[0+e]*r,i._m[1]=t[1+e]*r,i._m[2]=t[2+e]*r,i._m[3]=t[3+e]*r,i._m[4]=t[4+e]*r,i._m[5]=t[5+e]*r,i._m[6]=t[6+e]*r,i._m[7]=t[7+e]*r,i._m[8]=t[8+e]*r,i._m[9]=t[9+e]*r,i._m[10]=t[10+e]*r,i._m[11]=t[11+e]*r,i._m[12]=t[12+e]*r,i._m[13]=t[13+e]*r,i._m[14]=t[14+e]*r,i._m[15]=t[15+e]*r,i.markAsUpdated(),i}static get IdentityReadOnly(){return m._IdentityReadOnly}static FromValuesToRef(t,e,r,i,s,o,n,a,h,_,c,y,l,u,m,x,f){const R=f._m;R[0]=t,R[1]=e,R[2]=r,R[3]=i,R[4]=s,R[5]=o,R[6]=n,R[7]=a,R[8]=h,R[9]=_,R[10]=c,R[11]=y,R[12]=l,R[13]=u,R[14]=m,R[15]=x,f.markAsUpdated()}static FromValues(t,e,r,i,s,o,n,a,h,_,c,y,l,u,x,f){const R=new m,d=R._m;return d[0]=t,d[1]=e,d[2]=r,d[3]=i,d[4]=s,d[5]=o,d[6]=n,d[7]=a,d[8]=h,d[9]=_,d[10]=c,d[11]=y,d[12]=l,d[13]=u,d[14]=x,d[15]=f,R.markAsUpdated(),R}static Compose(t,e,r){const i=new m;return m.ComposeToRef(t,e,r,i),i}static ComposeToRef(t,e,r,i){const s=i._m,o=e._x,n=e._y,a=e._z,h=e._w,_=o+o,c=n+n,y=a+a,l=o*_,u=o*c,m=o*y,x=n*c,f=n*y,R=a*y,d=h*_,z=h*c,T=h*y,w=t._x,p=t._y,F=t._z;return s[0]=(1-(x+R))*w,s[1]=(u+T)*w,s[2]=(m-z)*w,s[3]=0,s[4]=(u-T)*p,s[5]=(1-(l+R))*p,s[6]=(f+d)*p,s[7]=0,s[8]=(m+z)*F,s[9]=(f-d)*F,s[10]=(1-(l+x))*F,s[11]=0,s[12]=r._x,s[13]=r._y,s[14]=r._z,s[15]=1,i.markAsUpdated(),i}static Identity(){const t=m.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=m.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const e=new m;return m.RotationXToRef(t,e),e}static Invert(t){const e=new m;return t.invertToRef(e),e}static RotationXToRef(t,e){const r=Math.sin(t),i=Math.cos(t);return m.FromValuesToRef(1,0,0,0,0,i,r,0,0,-r,i,0,0,0,0,1,e),e._updateIdentityStatus(1===i&&0===r),e}static RotationY(t){const e=new m;return m.RotationYToRef(t,e),e}static RotationYToRef(t,e){const r=Math.sin(t),i=Math.cos(t);return m.FromValuesToRef(i,0,-r,0,0,1,0,0,r,0,i,0,0,0,0,1,e),e._updateIdentityStatus(1===i&&0===r),e}static RotationZ(t){const e=new m;return m.RotationZToRef(t,e),e}static RotationZToRef(t,e){const r=Math.sin(t),i=Math.cos(t);return m.FromValuesToRef(i,r,0,0,-r,i,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(1===i&&0===r),e}static RotationAxis(t,e){const r=new m;return m.RotationAxisToRef(t,e,r),r}static RotationAxisToRef(t,e,r){const i=Math.sin(-e),s=Math.cos(-e),o=1-s;t=t.normalizeToRef(x.Vector3[0]);const n=r._m;return n[0]=t._x*t._x*o+s,n[1]=t._x*t._y*o-t._z*i,n[2]=t._x*t._z*o+t._y*i,n[3]=0,n[4]=t._y*t._x*o+t._z*i,n[5]=t._y*t._y*o+s,n[6]=t._y*t._z*o-t._x*i,n[7]=0,n[8]=t._z*t._x*o-t._y*i,n[9]=t._z*t._y*o+t._x*i,n[10]=t._z*t._z*o+s,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,r.markAsUpdated(),r}static RotationAlignToRef(t,e,r,s=!1){const o=y.Dot(e,t),n=r._m;if(o<-1+i.bH)n[0]=-1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=s?1:-1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=s?-1:1,n[11]=0;else{const r=y.Cross(e,t),i=1/(1+o);n[0]=r._x*r._x*i+o,n[1]=r._y*r._x*i-r._z,n[2]=r._z*r._x*i+r._y,n[3]=0,n[4]=r._x*r._y*i+r._z,n[5]=r._y*r._y*i+o,n[6]=r._z*r._y*i-r._x,n[7]=0,n[8]=r._x*r._z*i-r._y,n[9]=r._y*r._z*i+r._x,n[10]=r._z*r._z*i+o,n[11]=0}return n[12]=0,n[13]=0,n[14]=0,n[15]=1,r.markAsUpdated(),r}static RotationYawPitchRoll(t,e,r){const i=new m;return m.RotationYawPitchRollToRef(t,e,r,i),i}static RotationYawPitchRollToRef(t,e,r,i){return u.RotationYawPitchRollToRef(t,e,r,x.Quaternion[0]),x.Quaternion[0].toRotationMatrix(i),i}static Scaling(t,e,r){const i=new m;return m.ScalingToRef(t,e,r,i),i}static ScalingToRef(t,e,r,i){return m.FromValuesToRef(t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1,i),i._updateIdentityStatus(1===t&&1===e&&1===r),i}static Translation(t,e,r){const i=new m;return m.TranslationToRef(t,e,r,i),i}static TranslationToRef(t,e,r,i){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1,i),i._updateIdentityStatus(0===t&&0===e&&0===r),i}static Lerp(t,e,r){const i=new m;return m.LerpToRef(t,e,r,i),i}static LerpToRef(t,e,r,i){const s=i._m,o=t.m,n=e.m;for(let t=0;t<16;t++)s[t]=o[t]*(1-r)+n[t]*r;return i.markAsUpdated(),i}static DecomposeLerp(t,e,r){const i=new m;return m.DecomposeLerpToRef(t,e,r,i),i}static DecomposeLerpToRef(t,e,r,i){const s=x.Vector3[0],o=x.Quaternion[0],n=x.Vector3[1];t.decompose(s,o,n);const a=x.Vector3[2],h=x.Quaternion[1],_=x.Vector3[3];e.decompose(a,h,_);const c=x.Vector3[4];y.LerpToRef(s,a,r,c);const l=x.Quaternion[2];u.SlerpToRef(o,h,r,l);const f=x.Vector3[5];return y.LerpToRef(n,_,r,f),m.ComposeToRef(c,l,f,i),i}static LookAtLH(t,e,r){const i=new m;return m.LookAtLHToRef(t,e,r,i),i}static LookAtLHToRef(t,e,r,i){const s=x.Vector3[0],o=x.Vector3[1],n=x.Vector3[2];e.subtractToRef(t,n),n.normalize(),y.CrossToRef(r,n,s);const a=s.lengthSquared();0===a?s.x=1:s.normalizeFromLength(Math.sqrt(a)),y.CrossToRef(n,s,o),o.normalize();const h=-y.Dot(s,t),_=-y.Dot(o,t),c=-y.Dot(n,t);return m.FromValuesToRef(s._x,o._x,n._x,0,s._y,o._y,n._y,0,s._z,o._z,n._z,0,h,_,c,1,i),i}static LookAtRH(t,e,r){const i=new m;return m.LookAtRHToRef(t,e,r,i),i}static LookAtRHToRef(t,e,r,i){const s=x.Vector3[0],o=x.Vector3[1],n=x.Vector3[2];t.subtractToRef(e,n),n.normalize(),y.CrossToRef(r,n,s);const a=s.lengthSquared();0===a?s.x=1:s.normalizeFromLength(Math.sqrt(a)),y.CrossToRef(n,s,o),o.normalize();const h=-y.Dot(s,t),_=-y.Dot(o,t),c=-y.Dot(n,t);return m.FromValuesToRef(s._x,o._x,n._x,0,s._y,o._y,n._y,0,s._z,o._z,n._z,0,h,_,c,1,i),i}static LookDirectionLH(t,e){const r=new m;return m.LookDirectionLHToRef(t,e,r),r}static LookDirectionLHToRef(t,e,r){const i=x.Vector3[0];i.copyFrom(t),i.scaleInPlace(-1);const s=x.Vector3[1];return y.CrossToRef(e,i,s),m.FromValuesToRef(s._x,s._y,s._z,0,e._x,e._y,e._z,0,i._x,i._y,i._z,0,0,0,0,1,r),r}static LookDirectionRH(t,e){const r=new m;return m.LookDirectionRHToRef(t,e,r),r}static LookDirectionRHToRef(t,e,r){const i=x.Vector3[2];return y.CrossToRef(e,t,i),m.FromValuesToRef(i._x,i._y,i._z,0,e._x,e._y,e._z,0,t._x,t._y,t._z,0,0,0,0,1,r),r}static OrthoLH(t,e,r,i,s){const o=new m;return m.OrthoLHToRef(t,e,r,i,o,s),o}static OrthoLHToRef(t,e,r,i,s,o){const n=2/t,a=2/e,h=2/(i-r),_=-(i+r)/(i-r);return m.FromValuesToRef(n,0,0,0,0,a,0,0,0,0,h,0,0,0,_,1,s),o&&s.multiplyToRef(R,s),s._updateIdentityStatus(1===n&&1===a&&1===h&&0===_),s}static OrthoOffCenterLH(t,e,r,i,s,o,n){const a=new m;return m.OrthoOffCenterLHToRef(t,e,r,i,s,o,a,n),a}static OrthoOffCenterLHToRef(t,e,r,i,s,o,n,a){const h=2/(e-t),_=2/(i-r),c=2/(o-s),y=-(o+s)/(o-s),l=(t+e)/(t-e),u=(i+r)/(r-i);return m.FromValuesToRef(h,0,0,0,0,_,0,0,0,0,c,0,l,u,y,1,n),a&&n.multiplyToRef(R,n),n.markAsUpdated(),n}static ObliqueOffCenterLHToRef(t,e,r,i,s,o,n,a,h,_,c){const y=-n*Math.cos(a),l=-n*Math.sin(a);return m.TranslationToRef(0,0,-h,x.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,y,l,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),m.TranslationToRef(0,0,h,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),m.OrthoOffCenterLHToRef(t,e,r,i,s,o,_,c),x.Matrix[0].multiplyToRef(_,_),_}static OrthoOffCenterRH(t,e,r,i,s,o,n){const a=new m;return m.OrthoOffCenterRHToRef(t,e,r,i,s,o,a,n),a}static OrthoOffCenterRHToRef(t,e,r,i,s,o,n,a){return m.OrthoOffCenterLHToRef(t,e,r,i,s,o,n,a),n._m[10]*=-1,n}static ObliqueOffCenterRHToRef(t,e,r,i,s,o,n,a,h,_,c){const y=n*Math.cos(a),l=n*Math.sin(a);return m.TranslationToRef(0,0,h,x.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,y,l,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),m.TranslationToRef(0,0,-h,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),m.OrthoOffCenterRHToRef(t,e,r,i,s,o,_,c),x.Matrix[0].multiplyToRef(_,_),_}static PerspectiveLH(t,e,r,i,s,o=0){const n=new m,a=2*r/t,h=2*r/e,_=(i+r)/(i-r),c=-2*i*r/(i-r),y=Math.tan(o);return m.FromValuesToRef(a,0,0,0,0,h,0,y,0,0,_,1,0,0,c,0,n),s&&n.multiplyToRef(R,n),n._updateIdentityStatus(!1),n}static PerspectiveFovLH(t,e,r,i,s,o=0,n=!1){const a=new m;return m.PerspectiveFovLHToRef(t,e,r,i,a,!0,s,o,n),a}static PerspectiveFovLHToRef(t,e,r,i,s,o=!0,n,a=0,h=!1){const _=r,c=i,y=1/Math.tan(.5*t),l=o?y/e:y,u=o?y:y*e,x=h&&0===_?-1:0!==c?(c+_)/(c-_):1,f=h&&0===_?2*c:0!==c?-2*c*_/(c-_):-2*_,d=Math.tan(a);return m.FromValuesToRef(l,0,0,0,0,u,0,d,0,0,x,1,0,0,f,0,s),n&&s.multiplyToRef(R,s),s._updateIdentityStatus(!1),s}static PerspectiveFovReverseLHToRef(t,e,r,i,s,o=!0,n,a=0){const h=1/Math.tan(.5*t),_=o?h/e:h,c=o?h:h*e,y=Math.tan(a);return m.FromValuesToRef(_,0,0,0,0,c,0,y,0,0,-r,1,0,0,1,0,s),n&&s.multiplyToRef(R,s),s._updateIdentityStatus(!1),s}static PerspectiveFovRH(t,e,r,i,s,o=0,n=!1){const a=new m;return m.PerspectiveFovRHToRef(t,e,r,i,a,!0,s,o,n),a}static PerspectiveFovRHToRef(t,e,r,i,s,o=!0,n,a=0,h=!1){const _=r,c=i,y=1/Math.tan(.5*t),l=o?y/e:y,u=o?y:y*e,x=h&&0===_?1:0!==c?-(c+_)/(c-_):-1,f=h&&0===_?2*c:0!==c?-2*c*_/(c-_):-2*_,d=Math.tan(a);return m.FromValuesToRef(l,0,0,0,0,u,0,d,0,0,x,-1,0,0,f,0,s),n&&s.multiplyToRef(R,s),s._updateIdentityStatus(!1),s}static PerspectiveFovReverseRHToRef(t,e,r,i,s,o=!0,n,a=0){const h=1/Math.tan(.5*t),_=o?h/e:h,c=o?h:h*e,y=Math.tan(a);return m.FromValuesToRef(_,0,0,0,0,c,0,y,0,0,-r,-1,0,0,-1,0,s),n&&s.multiplyToRef(R,s),s._updateIdentityStatus(!1),s}static GetFinalMatrix(t,e,r,i,s,o){const n=t.width,a=t.height,h=t.x,_=t.y,c=m.FromValues(n/2,0,0,0,0,-a/2,0,0,0,0,o-s,0,h+n/2,a/2+_,s,1),y=new m;return e.multiplyToRef(r,y),y.multiplyToRef(i,y),y.multiplyToRef(c,y)}static GetAsMatrix2x2(t){const e=t.m,r=[e[0],e[1],e[4],e[5]];return n.I.MatrixUse64Bits?r:new Float32Array(r)}static GetAsMatrix3x3(t){const e=t.m,r=[e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]];return n.I.MatrixUse64Bits?r:new Float32Array(r)}static Transpose(t){const e=new m;return m.TransposeToRef(t,e),e}static TransposeToRef(t,e){const r=t.m,i=r[0],s=r[4],o=r[8],n=r[12],a=r[1],h=r[5],_=r[9],c=r[13],y=r[2],l=r[6],u=r[10],m=r[14],x=r[3],f=r[7],R=r[11],d=r[15],z=e._m;return z[0]=i,z[1]=s,z[2]=o,z[3]=n,z[4]=a,z[5]=h,z[6]=_,z[7]=c,z[8]=y,z[9]=l,z[10]=u,z[11]=m,z[12]=x,z[13]=f,z[14]=R,z[15]=d,e.markAsUpdated(),e._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),e}static Reflection(t){const e=new m;return m.ReflectionToRef(t,e),e}static ReflectionToRef(t,e){t.normalize();const r=t.normal.x,i=t.normal.y,s=t.normal.z,o=-2*r,n=-2*i,a=-2*s;return m.FromValuesToRef(o*r+1,n*r,a*r,0,o*i,n*i+1,a*i,0,o*s,n*s,a*s+1,0,o*t.d,n*t.d,a*t.d,1,e),e}static FromXYZAxesToRef(t,e,r,i){return m.FromValuesToRef(t._x,t._y,t._z,0,e._x,e._y,e._z,0,r._x,r._y,r._z,0,0,0,0,1,i),i}static FromQuaternionToRef(t,e){const r=t._x*t._x,i=t._y*t._y,s=t._z*t._z,o=t._x*t._y,n=t._z*t._w,a=t._z*t._x,h=t._y*t._w,_=t._y*t._z,c=t._x*t._w;return e._m[0]=1-2*(i+s),e._m[1]=2*(o+n),e._m[2]=2*(a-h),e._m[3]=0,e._m[4]=2*(o-n),e._m[5]=1-2*(s+r),e._m[6]=2*(_+c),e._m[7]=0,e._m[8]=2*(a+h),e._m[9]=2*(_-c),e._m[10]=1-2*(i+r),e._m[11]=0,e._m[12]=0,e._m[13]=0,e._m[14]=0,e._m[15]=1,e.markAsUpdated(),e}}m._UpdateFlagSeed=0,m._IdentityReadOnly=m.Identity(),Object.defineProperties(m.prototype,{dimension:{value:[4,4]},rank:{value:2}});class x{}x.Vector3=(0,s.ln)(11,y.Zero),x.Matrix=(0,s.ln)(2,m.Identity),x.Quaternion=(0,s.ln)(3,u.Zero);class f{}f.Vector2=(0,s.ln)(3,c.Zero),f.Vector3=(0,s.ln)(13,y.Zero),f.Vector4=(0,s.ln)(3,l.Zero),f.Quaternion=(0,s.ln)(3,u.Zero),f.Matrix=(0,s.ln)(8,m.Identity),(0,o.Y5)("BABYLON.Vector2",c),(0,o.Y5)("BABYLON.Vector3",y),(0,o.Y5)("BABYLON.Vector4",l),(0,o.Y5)("BABYLON.Matrix",m);const R=m.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)}}]);