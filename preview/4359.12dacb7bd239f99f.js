/*
 *  This file is part of Cosmos Journeyer
 *
 *  Copyright (C) 2024 Barthélemy Paléologue <barth.paleologue@cosmosjourneyer.com>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

"use strict";(globalThis.webpackChunkcosmos_journeyer=globalThis.webpackChunkcosmos_journeyer||[]).push([["4359"],{20333:function(e,t,r){r.d(t,{DDSTools:()=>A});var a=r(16891),l=r(88280),o=r(24103),n=r(60746);function f(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}r(41316);let s=f("DXT1"),i=f("DXT3"),u=f("DXT5"),c=f("DX10");class A{static GetDDSInfo(e){let t=new Int32Array(e.buffer,e.byteOffset,31),r=new Int32Array(e.buffer,e.byteOffset,35),a=1;131072&t[2]&&(a=Math.max(1,t[7]));let l=t[21],o=l===c?r[32]:0,n=0;switch(l){case 113:n=2;break;case 116:n=1;break;case c:if(10===o){n=2;break}2===o&&(n=1)}return{width:t[4],height:t[3],mipmapCount:a,isFourCC:(4&t[20])==4,isRGB:(64&t[20])==64,isLuminance:(131072&t[20])==131072,isCube:(512&t[28])==512,isCompressed:l===s||l===i||l===u,dxgiFormat:o,textureType:n}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,t,r,a,l,o){let f=new Float32Array(a),s=new Uint16Array(l,r),i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=(t+r*e)*4;f[i]=(0,n.qZ)(s[a]),f[i+1]=(0,n.qZ)(s[a+1]),f[i+2]=(0,n.qZ)(s[a+2]),A.StoreLODInAlphaChannel?f[i+3]=o:f[i+3]=(0,n.qZ)(s[a+3]),i+=4}return f}static _GetHalfFloatRGBAArrayBuffer(e,t,r,a,l,o){if(A.StoreLODInAlphaChannel){let f=new Uint16Array(a),s=new Uint16Array(l,r),i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=(t+r*e)*4;f[i]=s[a],f[i+1]=s[a+1],f[i+2]=s[a+2],f[i+3]=(0,n.ay)(o),i+=4}return f}return new Uint16Array(l,r,a)}static _GetFloatRGBAArrayBuffer(e,t,r,a,l,o){if(A.StoreLODInAlphaChannel){let n=new Float32Array(a),f=new Float32Array(l,r),s=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=(t+r*e)*4;n[s]=f[a],n[s+1]=f[a+1],n[s+2]=f[a+2],n[s+3]=o,s+=4}return n}return new Float32Array(l,r,a)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,t,r,a,l,o){let f=new Uint16Array(a),s=new Float32Array(l,r),i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++)f[i]=(0,n.ay)(s[i]),f[i+1]=(0,n.ay)(s[i+1]),f[i+2]=(0,n.ay)(s[i+2]),A.StoreLODInAlphaChannel?f[i+3]=(0,n.ay)(o):f[i+3]=(0,n.ay)(s[i+3]),i+=4;return f}static _GetFloatAsUIntRGBAArrayBuffer(e,t,r,l,o,n){let f=new Uint8Array(l),s=new Float32Array(o,r),i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let l=(t+r*e)*4;f[i]=255*(0,a.Clamp)(s[l]),f[i+1]=255*(0,a.Clamp)(s[l+1]),f[i+2]=255*(0,a.Clamp)(s[l+2]),A.StoreLODInAlphaChannel?f[i+3]=n:f[i+3]=255*(0,a.Clamp)(s[l+3]),i+=4}return f}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,t,r,l,o,f){let s=new Uint8Array(l),i=new Uint16Array(o,r),u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let l=(t+r*e)*4;s[u]=255*(0,a.Clamp)((0,n.qZ)(i[l])),s[u+1]=255*(0,a.Clamp)((0,n.qZ)(i[l+1])),s[u+2]=255*(0,a.Clamp)((0,n.qZ)(i[l+2])),A.StoreLODInAlphaChannel?s[u+3]=f:s[u+3]=255*(0,a.Clamp)((0,n.qZ)(i[l+3])),u+=4}return s}static _GetRGBAArrayBuffer(e,t,r,a,l,o,n,f,s){let i=new Uint8Array(a),u=new Uint8Array(l,r),c=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=(t+r*e)*4;i[c]=u[a+o],i[c+1]=u[a+n],i[c+2]=u[a+f],i[c+3]=u[a+s],c+=4}return i}static _ExtractLongWordOrder(e){return 0===e||255===e||-0x1000000===e?0:1+A._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,t,r,a,l,o,n,f){let s=new Uint8Array(a),i=new Uint8Array(l,r),u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=(t+r*e)*3;s[u]=i[a+o],s[u+1]=i[a+n],s[u+2]=i[a+f],u+=3}return s}static _GetLuminanceArrayBuffer(e,t,r,a,l){let o=new Uint8Array(a),n=new Uint8Array(l,r),f=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){let a=t+r*e;o[f]=n[a],f++}return o}static UploadDDSLevels(e,t,r,a,n,f,y=-1,d,p=!0){let h,_,b,C=null;a.sphericalPolynomial&&(C=[]);let B=!!e.getCaps().s3tc;t.generateMipMaps=n;let G=new Int32Array(r.buffer,r.byteOffset,31),m,F,w,x=0,g,D=0,L=1;if(0x20534444!==G[0])return void l.Y.Error("Invalid magic number in DDS header");if(!a.isFourCC&&!a.isRGB&&!a.isLuminance)return void l.Y.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(a.isCompressed&&!B)return void l.Y.Error("Compressed textures are not supported on this platform.");let R=G[22];g=G[1]+4;let U=!1;if(a.isFourCC)switch(m=G[21]){case s:L=8,D=33777;break;case i:L=16,D=33778;break;case u:L=16,D=33779;break;case 113:U=!0,R=64;break;case 116:U=!0,R=128;break;case c:{g+=20;let e=!1;switch(a.dxgiFormat){case 10:U=!0,R=64,e=!0;break;case 2:U=!0,R=128,e=!0;break;case 88:a.isRGB=!0,a.isFourCC=!1,R=32,e=!0}if(e)break}default:l.Y.Error(["Unsupported FourCC code:",String.fromCharCode(255&m,m>>8&255,m>>16&255,m>>24&255)]);return}let O=A._ExtractLongWordOrder(G[23]),I=A._ExtractLongWordOrder(G[24]),T=A._ExtractLongWordOrder(G[25]),k=A._ExtractLongWordOrder(G[26]);U&&(D=e._getRGBABufferInternalSizedFormat(a.textureType)),_=1,131072&G[2]&&!1!==n&&(_=Math.max(1,G[7]));let S=d||0,v=e.getCaps();for(let l=S;l<f;l++){for(b=0,F=G[4],w=G[3];b<_;++b){if(-1===y||y===b){let o=-1===y?b:0;if(!a.isCompressed&&a.isFourCC){t.format=5,x=F*w*4;let a=null;if(e._badOS||e._badDesktopOS||!v.textureHalfFloat&&!v.textureFloat)128===R?(a=A._GetFloatAsUIntRGBAArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,o),C&&0==o&&C.push(A._GetFloatRGBAArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,o))):64===R&&(a=A._GetHalfFloatAsUIntRGBAArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,o),C&&0==o&&C.push(A._GetHalfFloatAsFloatRGBAArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,o))),t.type=0;else{let e,l=v.textureFloat&&(p&&v.textureFloatLinearFiltering||!p),n=v.textureHalfFloat&&(p&&v.textureHalfFloatLinearFiltering||!p),f=(128===R||64===R&&!n)&&l?1:(64===R||128===R&&!l)&&n?2:0,s=null;if(128===R)switch(f){case 1:e=A._GetFloatRGBAArrayBuffer,s=null;break;case 2:e=A._GetFloatAsHalfFloatRGBAArrayBuffer,s=A._GetFloatRGBAArrayBuffer;break;case 0:e=A._GetFloatAsUIntRGBAArrayBuffer,s=A._GetFloatRGBAArrayBuffer}else switch(f){case 1:e=A._GetHalfFloatAsFloatRGBAArrayBuffer,s=null;break;case 2:e=A._GetHalfFloatRGBAArrayBuffer,s=A._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:e=A._GetHalfFloatAsUIntRGBAArrayBuffer,s=A._GetHalfFloatAsFloatRGBAArrayBuffer}t.type=f,a=e(F,w,r.byteOffset+g,x,r.buffer,o),C&&0==o&&C.push(s?s(F,w,r.byteOffset+g,x,r.buffer,o):a)}a&&e._uploadDataToTextureDirectly(t,a,l,o)}else if(a.isRGB)t.type=0,24===R?(t.format=4,x=F*w*3,h=A._GetRGBArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,O,I,T)):(t.format=5,x=F*w*4,h=A._GetRGBAArrayBuffer(F,w,r.byteOffset+g,x,r.buffer,O,I,T,k)),e._uploadDataToTextureDirectly(t,h,l,o);else if(a.isLuminance){let a=e._getUnpackAlignement(),n=F;x=Math.floor((F+a-1)/a)*a*(w-1)+n,h=A._GetLuminanceArrayBuffer(F,w,r.byteOffset+g,x,r.buffer),t.format=1,t.type=0,e._uploadDataToTextureDirectly(t,h,l,o)}else x=Math.max(4,F)/4*Math.max(4,w)/4*L,h=new Uint8Array(r.buffer,r.byteOffset+g,x),t.type=0,e._uploadCompressedDataToTextureDirectly(t,D,F,w,h,l,o)}g+=R?F*w*(R/8):x,F*=.5,w*=.5,F=Math.max(1,F),w=Math.max(1,w)}if(void 0!==d)break}C&&C.length>0?a.sphericalPolynomial=o.$.ConvertCubeMapToSphericalPolynomial({size:G[4],right:C[0],left:C[1],up:C[2],down:C[3],front:C[4],back:C[5],format:5,type:1,gammaSpace:!1}):a.sphericalPolynomial=void 0}}A.StoreLODInAlphaChannel=!1},36020:function(e,t,r){r.d(t,{t:()=>a});function a(e){let t=e.split("?")[0],r=t.lastIndexOf(".");return r>-1?t.substring(r).toLowerCase():""}},41316:function(e,t,r){var a=r(90481),l=r(88280),o=r(21381),n=r(53986),f=r(74913),s=r(14366),i=r(36020);f.a.prototype._partialLoadFile=function(e,t,r,a,l=null){this._loadFile(e,e=>{r[t]=e,r._internalCount++,6===r._internalCount&&a(r)},void 0,void 0,!0,(e,t)=>{l&&e&&l(e.status+" "+e.statusText,t)})},f.a.prototype._cascadeLoadFiles=function(e,t,r,a=null){let l=[];l._internalCount=0;for(let e=0;e<6;e++)this._partialLoadFile(r[e],e,l,t,a)},f.a.prototype._cascadeLoadImgs=function(e,t,r,a,l=null,o){let n=[];n._internalCount=0;for(let f=0;f<6;f++)this._partialLoadImg(a[f],f,n,e,t,r,l,o)},f.a.prototype._partialLoadImg=function(e,t,r,a,l,f,s=null,i){let u=(0,n.f)();(0,o.r6)(e,e=>{r[t]=e,r._internalCount++,a&&a.removePendingData(u),6===r._internalCount&&f&&f(l,r)},(e,t)=>{a&&a.removePendingData(u),s&&s(e,t)},a?a.offlineProvider:null,i),a&&a.addPendingData(u)},f.a.prototype.createCubeTextureBase=function(e,t,r,o,n=null,f=null,u,c=null,A=!1,y=0,d=0,p=null,h=null,_=null,b=!1,C=null){let B=p||new a.l(this,7);B.isCube=!0,B.url=e,B.generateMipMaps=!o,B._lodGenerationScale=y,B._lodGenerationOffset=d,B._useSRGBBuffer=!!b&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!o),B!==p&&(B.label=e.substring(0,60)),this._doNotHandleContextLost||(B._extension=c,B._files=r,B._buffer=C);let G=e;this._transformTextureUrl&&!p&&(e=this._transformTextureUrl(e));let m=c??(0,i.t)(e),F=(0,s.qr)(m),w=(e,t)=>{B.dispose(),f?f(e,t):e&&l.Y.Warn(e)},x=(a,f)=>{e===G?a&&w(a.status+" "+a.statusText,f):(l.Y.Warn(`Failed to load ${e}, falling back to the ${G}`),this.createCubeTextureBase(G,t,r,!!o,n,w,u,c,A,y,d,B,h,_,b,C))};if(F)F.then(a=>{let l=e=>{h&&h(B,e),a.loadCubeData(e,B,A,n,(e,t)=>{w(e,t)})};C?l(C):r&&6===r.length?a.supportCascades?this._cascadeLoadFiles(t,e=>l(e.map(e=>new Uint8Array(e))),r,w):w("Textures type does not support cascades."):this._loadFile(e,e=>l(new Uint8Array(e)),void 0,void 0,!0,x)});else{if(!r||0===r.length)throw Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(t,B,(e,t)=>{_&&_(e,t)},r,w)}return this._internalTexturesCache.push(B),B}}}]);