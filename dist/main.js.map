{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,6CAA6C,2FAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kDAAkD,2FAAsC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5GO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;;;;ACRS;AACA;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAY;AACzB;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,aAAa,yDAAiB;AAC9B;AACA;AACA,aAAa,0DAAkB;AAC/B;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,aAAa,uDAAe;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,WAAW,KAAK,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,sBAAsB,uDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,oDAAY;AAC7B;AACA;AACA,iBAAiB,sDAAc;AAC/B;AACA;AACA,iBAAiB,yDAAiB;AAClC;AACA;AACA,iBAAiB,0DAAkB;AACnC;AACA;AACA,iBAAiB,sDAAc;AAC/B;AACA;AACA,iBAAiB,uDAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9HiF;AACzC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAiB;AAC3C;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iFAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1JgD;AACF;AAC9C;AACmE;AAChB;AACE;AACc;AACA;AAC5D;AACP;AACA,mCAAmC;AACnC;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA,gBAAgB,yDAAU,IAAI,QAAQ,iDAAiD,0DAAY;AACnG,gBAAgB,yDAAU,IAAI,QAAQ,mDAAmD,4DAAc;AACvG,gBAAgB,yDAAU,IAAI,QAAQ,sDAAsD,+DAAiB;AAC7G,gBAAgB,yDAAU,IAAI,QAAQ,uDAAuD,gEAAkB;AAC/G,gBAAgB,yDAAU,IAAI,QAAQ,oDAAoD,6DAAe;AACzG,gBAAgB,yDAAU,IAAI,QAAQ,mDAAmD,4DAAc;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0EAA0E,8DAAa;AACvF,yEAAyE,sDAAK;AAC9E,yEAAyE,uDAAM;AAC/E,wEAAwE,8DAAa;AACrF,wEAAwE,8DAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAAyE;AACpG;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3JO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpE2D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0DAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC/DA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;;;;;;;;;;;;;;;ACrBoG;AACvD;AACuB;AACT;AACR;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0CAA0C,oDAAU;AACpD;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B,iBAAiB,sDAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6GAAgC;AACrD;AACA;AACA;AACA;AACA,gBAAgB,6EAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,sFAAsF,cAAc;AACpG;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC","sources":["webpack://my-webpack-project/./src/ts/components/forge/chunkForge.ts","webpack://my-webpack-project/./src/ts/components/forge/direction.ts","webpack://my-webpack-project/./src/ts/components/forge/planetChunk.ts","webpack://my-webpack-project/./src/ts/components/forge/planetSide.ts","webpack://my-webpack-project/./src/ts/components/planet.ts","webpack://my-webpack-project/./src/ts/postProcesses/atmosphericScatteringPostProcess.ts","webpack://my-webpack-project/./src/ts/postProcesses/oceanPostProcess.ts","webpack://my-webpack-project/webpack/bootstrap","webpack://my-webpack-project/webpack/runtime/define property getters","webpack://my-webpack-project/webpack/runtime/get javascript chunk filename","webpack://my-webpack-project/webpack/runtime/global","webpack://my-webpack-project/webpack/runtime/hasOwnProperty shorthand","webpack://my-webpack-project/webpack/runtime/make namespace object","webpack://my-webpack-project/webpack/runtime/publicPath","webpack://my-webpack-project/webpack/runtime/jsonp chunk loading","webpack://my-webpack-project/./src/ts/showcase.ts"],"sourcesContent":["export var TaskType;\n(function (TaskType) {\n    TaskType[TaskType[\"Deletion\"] = 0] = \"Deletion\";\n    TaskType[TaskType[\"Build\"] = 1] = \"Build\";\n    TaskType[TaskType[\"Apply\"] = 2] = \"Apply\";\n    TaskType[TaskType[\"Init\"] = 3] = \"Init\";\n})(TaskType || (TaskType = {}));\nexport class ChunkForge {\n    constructor(_subdivisions, _depthRenderer, _scene) {\n        // What you need to generate a beautiful terrain (à étendre pour ne pas tout hardcode dans le worker)\n        this.craters = [];\n        this.incomingTasks = [];\n        this.trashCan = [];\n        this.applyTasks = [];\n        this.cadence = 6;\n        this.builders = [];\n        this.esclavesDispo = [];\n        this.subdivisions = _subdivisions;\n        for (let i = 0; i < this.cadence; i++) {\n            let builder = new Worker(new URL('./builder.worker.ts', import.meta.url));\n            this.builders.push(builder);\n            this.esclavesDispo.push(builder);\n        }\n        this.depthRenderer = _depthRenderer;\n        this.scene = _scene;\n    }\n    addTask(task) {\n        this.incomingTasks.push(task);\n    }\n    executeTask(task) {\n        switch (task.taskType) {\n            case TaskType.Build:\n                let mesh = task.mesh;\n                let esclave = this.esclavesDispo.shift();\n                // les tâches sont ajoutées de sorte que les tâches de créations sont suivies de leurs\n                // tâches de supressions associées : on les stock et on les execute après les créations\n                let callbackTasks = [];\n                while (this.incomingTasks.length > 0 && this.incomingTasks[0].taskType == TaskType.Deletion) {\n                    //@ts-ignore\n                    callbackTasks.push(this.incomingTasks.shift());\n                }\n                esclave?.postMessage({\n                    taskType: \"buildTask\",\n                    chunkLength: task.chunkLength,\n                    subdivisions: this.subdivisions,\n                    depth: task.depth,\n                    direction: task.direction,\n                    position: [task.position.x, task.position.y, task.position.z],\n                    craters: task.planet.craters,\n                    noiseModifiers: task.planet.noiseModifiers,\n                    craterModifiers: task.planet.craterModifiers,\n                });\n                const worker = new Worker(new URL('./builder.worker.ts', import.meta.url));\n                esclave.onmessage = e => {\n                    let vertexData = new BABYLON.VertexData();\n                    vertexData.positions = Array.from(e.data.p);\n                    vertexData.indices = Array.from(e.data.i);\n                    vertexData.normals = Array.from(e.data.n);\n                    this.applyTasks.push({\n                        id: task.id,\n                        taskType: TaskType.Apply,\n                        mesh: mesh,\n                        vertexData: vertexData,\n                        callbackTasks: callbackTasks,\n                    });\n                    this.esclavesDispo.push(esclave);\n                };\n                break;\n            case TaskType.Deletion:\n                // une tâche de suppression solitaire ne devrait pas exister\n                console.warn(\"Tâche de supression solitaire détectée\");\n                this.trashCan.push(task);\n                break;\n            default:\n                console.warn(\"Tache illegale\");\n                this.executeNextTask();\n        }\n    }\n    executeNextTask() {\n        if (this.incomingTasks.length > 0) {\n            this.executeTask(this.incomingTasks.shift());\n        }\n    }\n    emptyTrashCan(n) {\n        for (let i = 0; i < n; i++) {\n            if (this.trashCan.length > 0) {\n                let task = this.trashCan.shift();\n                task.mesh.dispose();\n            }\n        }\n    }\n    executeNextApplyTask() {\n        if (this.applyTasks.length > 0) {\n            let task = this.applyTasks.shift();\n            task.vertexData.applyToMesh(task.mesh);\n            this.depthRenderer.getDepthMap().renderList?.push(task.mesh);\n            setTimeout(() => {\n                this.trashCan = this.trashCan.concat(task.callbackTasks);\n            }, 100);\n        }\n    }\n    update() {\n        for (let esclave of this.esclavesDispo) {\n            this.executeNextTask();\n        }\n        this.executeNextApplyTask();\n        this.emptyTrashCan(10);\n    }\n}\n","export var Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n    Direction[Direction[\"Left\"] = 2] = \"Left\";\n    Direction[Direction[\"Right\"] = 3] = \"Right\";\n    Direction[Direction[\"Forward\"] = 4] = \"Forward\";\n    Direction[Direction[\"Backward\"] = 5] = \"Backward\";\n})(Direction || (Direction = {}));\n","import { TaskType } from \"./chunkForge\";\nimport { Direction } from \"./direction\";\n/**\n * Returns the chunk position in plane space\n * @param chunkLength the length of a chunk\n * @param path the path of the chunk\n * @returns the plane coordinates of the chunk\n */\nexport function getChunkPlaneSpacePositionFromPath(chunkLength, path) {\n    let [x, y] = [0, 0];\n    for (let i = 0; i < path.length; i++) {\n        /*\n            3   2\n              +\n            0   1\n        */\n        // i have no idea why i divide by four but it works heh\n        switch (path[i]) {\n            case 0:\n                x -= chunkLength / 4 / (2 ** i);\n                y -= chunkLength / 4 / (2 ** i);\n                break;\n            case 1:\n                x += chunkLength / 4 / (2 ** i);\n                y -= chunkLength / 4 / (2 ** i);\n                break;\n            case 2:\n                x += chunkLength / 4 / (2 ** i);\n                y += chunkLength / 4 / (2 ** i);\n                break;\n            case 3:\n                x -= chunkLength / 4 / (2 ** i);\n                y += chunkLength / 4 / (2 ** i);\n                break;\n        }\n    }\n    return new BABYLON.Vector3(x, y, 0);\n}\n/**\n * Returns chunk position in sphere space (doesn't account for rotation of the planet yet tho)\n * @param chunkLength the length of the chunk\n * @param path the path to the chunk in the quadtree\n * @param direction direction of the parent plane\n * @returns the position in sphere space (no planet rotation)\n */\nexport function getChunkSphereSpacePositionFromPath(chunkLength, path, direction) {\n    let position = getChunkPlaneSpacePositionFromPath(chunkLength, path);\n    position.addInPlace(new BABYLON.Vector3(0, 0, -chunkLength / 2));\n    position = position.normalizeToNew().scale(chunkLength / 2);\n    let rotation = BABYLON.Matrix.Identity();\n    switch (direction) {\n        case Direction.Up:\n            rotation = BABYLON.Matrix.RotationX(Math.PI / 2);\n            break;\n        case Direction.Down:\n            rotation = BABYLON.Matrix.RotationX(-Math.PI / 2);\n            break;\n        case Direction.Forward:\n            rotation = BABYLON.Matrix.Identity();\n            break;\n        case Direction.Backward:\n            rotation = BABYLON.Matrix.RotationY(Math.PI);\n            break;\n        case Direction.Left:\n            rotation = BABYLON.Matrix.RotationY(-Math.PI / 2);\n            break;\n        case Direction.Right:\n            rotation = BABYLON.Matrix.RotationY(Math.PI / 2);\n            break;\n    }\n    return BABYLON.Vector3.TransformCoordinates(position, rotation);\n}\nexport class PlanetChunk {\n    constructor(_path, _chunkLength, _direction, _parentNode, scene, chunkForge, surfaceMaterial, planet) {\n        // coordonnées sur le plan\n        this.x = 0;\n        this.y = 0;\n        this.id = `[D${_direction}][P${_path.join(\"\")}]`;\n        this.path = _path;\n        this.chunkLength = _chunkLength;\n        this.baseSubdivisions = chunkForge.subdivisions;\n        this.depth = this.path.length;\n        this.direction = _direction;\n        this.parentNode = _parentNode;\n        this.position = getChunkPlaneSpacePositionFromPath(this.chunkLength, this.path);\n        this.position.addInPlace(new BABYLON.Vector3(0, 0, -this.chunkLength / 2));\n        this.mesh = new BABYLON.Mesh(`Chunk${this.id}`, scene);\n        this.mesh.material = surfaceMaterial;\n        //this.mesh.material.wireframe = true;\n        this.mesh.parent = this.parentNode;\n        chunkForge.addTask({\n            taskType: TaskType.Build,\n            id: this.id,\n            planet: planet,\n            position: this.position,\n            chunkLength: this.chunkLength,\n            depth: this.depth,\n            direction: this.direction,\n            mesh: this.mesh,\n        });\n        this.position = this.position.normalizeToNew().scale(this.chunkLength / 2);\n        let rotation = BABYLON.Matrix.Identity();\n        switch (this.direction) {\n            case Direction.Up:\n                rotation = BABYLON.Matrix.RotationX(Math.PI / 2);\n                break;\n            case Direction.Down:\n                rotation = BABYLON.Matrix.RotationX(-Math.PI / 2);\n                break;\n            case Direction.Forward:\n                rotation = BABYLON.Matrix.Identity();\n                break;\n            case Direction.Backward:\n                rotation = BABYLON.Matrix.RotationY(Math.PI);\n                break;\n            case Direction.Left:\n                rotation = BABYLON.Matrix.RotationY(-Math.PI / 2);\n                break;\n            case Direction.Right:\n                rotation = BABYLON.Matrix.RotationY(Math.PI / 2);\n                break;\n        }\n        this.position = BABYLON.Vector3.TransformCoordinates(this.position, rotation);\n        //console.log(surfaceMaterial);\n        //this.mesh.material = surfaceMaterial;\n    }\n}\n","import { getChunkSphereSpacePositionFromPath, PlanetChunk } from \"./planetChunk\";\nimport { TaskType } from \"./chunkForge\";\n/**\n * Un PlanetSide est un plan généré procéduralement qui peut être morph à volonté\n */\nexport class PlanetSide {\n    /**\n     *\n     * @param _id\n     * @param _minDepth\n     * @param _maxDepth\n     * @param _chunkLength\n     * @param _direction\n     * @param _parentNode\n     * @param _scene\n     * @param _chunkForge\n     * @param _surfaceMaterial\n     * @param _planet\n     */\n    constructor(_id, _minDepth, _maxDepth, _chunkLength, _direction, _parentNode, _scene, _chunkForge, _surfaceMaterial, _planet) {\n        this.renderDistanceFactor = 3;\n        this.id = _id;\n        this.maxDepth = _maxDepth;\n        this.minDepth = _minDepth;\n        this.chunkLength = _chunkLength;\n        this.baseSubdivisions = _chunkForge.subdivisions;\n        this.direction = _direction;\n        this.parent = _parentNode;\n        this.scene = _scene;\n        this.chunkForge = _chunkForge;\n        this.surfaceMaterial = _surfaceMaterial;\n        this.planet = _planet;\n        // on initialise le plan avec un unique chunk\n        this.tree = this.createChunk([]);\n    }\n    /**\n     * Function used to execute code on every chunk of the quadtree\n     * @param tree the tree to explore\n     * @param f the function to apply on every chunk\n     */\n    executeOnEveryChunk(f, tree = this.tree) {\n        if (tree instanceof PlanetChunk) {\n            f(tree);\n        }\n        else {\n            for (let stem of tree)\n                this.executeOnEveryChunk(f, stem);\n        }\n    }\n    /**\n     * Send deletion request to chunkforge regarding the chunks of a branch\n     * @param tree The tree to delete\n     */\n    requestDeletion(tree) {\n        this.executeOnEveryChunk((chunk) => {\n            this.chunkForge.addTask({\n                taskType: TaskType.Deletion,\n                id: chunk.id,\n                mesh: chunk.mesh,\n            });\n        }, tree);\n    }\n    /**\n     * Update LOD of terrain relative to the observerPosition\n     * @param observerPosition The observer position\n     */\n    updateLOD(observerPosition, facingDirection) {\n        this.tree = this.updateLODRecursively(observerPosition, facingDirection);\n    }\n    /**\n     * Recursive function used internaly to update LOD\n     * @param observerPosition The observer position\n     * @param tree The tree to update recursively\n     * @param walked The position of the current root relative to the absolute root\n     * @returns The updated tree\n     */\n    updateLODRecursively(observerPosition, facingDirection, tree = this.tree, walked = []) {\n        // position du noeud du quadtree par rapport à la sphère \n        let relativePosition = getChunkSphereSpacePositionFromPath(this.chunkLength, walked, this.direction);\n        relativePosition = BABYLON.Vector3.TransformCoordinates(relativePosition, BABYLON.Matrix.RotationX(this.parent.rotation.x));\n        relativePosition = BABYLON.Vector3.TransformCoordinates(relativePosition, BABYLON.Matrix.RotationY(this.parent.rotation.y));\n        relativePosition = BABYLON.Vector3.TransformCoordinates(relativePosition, BABYLON.Matrix.RotationZ(this.parent.rotation.z));\n        // position par rapport à la caméra\n        let absolutePosition = relativePosition.add(this.parent.absolutePosition);\n        let direction = absolutePosition.subtract(observerPosition);\n        let dot = BABYLON.Vector3.Dot(direction, facingDirection);\n        // distance carré entre caméra et noeud du quadtree\n        let d = direction.lengthSquared();\n        let limit = this.renderDistanceFactor * (this.chunkLength / (2 ** walked.length));\n        if ((d < limit ** 2 && walked.length < this.maxDepth) || walked.length < this.minDepth) {\n            // si on est proche de la caméra ou si on doit le générer car LOD minimal\n            if (tree instanceof PlanetChunk) {\n                // si c'est un chunk, on le subdivise\n                let newTree = [\n                    this.createChunk(walked.concat([0])),\n                    this.createChunk(walked.concat([1])),\n                    this.createChunk(walked.concat([2])),\n                    this.createChunk(walked.concat([3])),\n                ];\n                this.requestDeletion(tree);\n                return newTree;\n            }\n            else {\n                // si c'en est pas un, on continue\n                return [\n                    this.updateLODRecursively(observerPosition, facingDirection, tree[0], walked.concat([0])),\n                    this.updateLODRecursively(observerPosition, facingDirection, tree[1], walked.concat([1])),\n                    this.updateLODRecursively(observerPosition, facingDirection, tree[2], walked.concat([2])),\n                    this.updateLODRecursively(observerPosition, facingDirection, tree[3], walked.concat([3])),\n                ];\n            }\n        }\n        else {\n            // si on est loin\n            if (tree instanceof PlanetChunk) {\n                //let camera = this.scene.activeCamera?.position;\n                let distanceToCenter = BABYLON.Vector3.DistanceSquared(observerPosition, this.parent.absolutePosition);\n                // c'est pythagore\n                let behindHorizon = (d > distanceToCenter + (this.chunkLength / 2) ** 2);\n                //tree.mesh.setEnabled(!behindHorizon);\n                return tree;\n            }\n            else {\n                // si c'est un noeud, on supprime tous les enfants, on remplace par un nouveau chunk\n                if (walked.length > this.minDepth) {\n                    let newChunk = this.createChunk(walked);\n                    this.requestDeletion(tree);\n                    return newChunk;\n                }\n                else {\n                    return tree;\n                }\n            }\n        }\n    }\n    /**\n     * Create new chunk of terrain at the specified location\n     * @param path The path leading to the location where to add the new chunk\n     * @returns The new Chunk\n     */\n    createChunk(path) {\n        return new PlanetChunk(path, this.chunkLength, this.direction, this.parent, this.scene, this.chunkForge, this.surfaceMaterial, this.planet);\n    }\n    setChunkMaterial(material) {\n        this.surfaceMaterial = material;\n    }\n    /**\n     * Regenerate planet chunks\n     */\n    reset() {\n        let newTree = this.createChunk([]);\n        this.requestDeletion(this.tree);\n        this.tree = newTree;\n    }\n}\n","import { PlanetSide } from \"./forge/planetSide\";\nimport { Direction } from \"./forge/direction\";\n//texture import\nimport crackednormal from \"../../asset/textures/crackednormal.jpg\";\nimport rockn from \"../../asset/textures/rockn.png\";\nimport grassn from \"../../asset/textures/grassn.png\";\nimport snowNormalMap from \"../../asset/textures/snowNormalMap.jpg\";\nimport sandNormalMap from \"../../asset/textures/sandNormalMap.jpg\";\nexport class Planet {\n    constructor(_id, _radius, _position, _nbSubdivisions, _minDepth, _maxDepth, _forge, _scene) {\n        this.sides = new Array(6); // stores the 6 sides of the sphere\n        this.id = _id;\n        this.radius = _radius;\n        this.chunkLength = this.radius * 2;\n        this.attachNode = BABYLON.Mesh.CreateBox(`${this.id}AttachNode`, 1, _scene);\n        this.attachNode.position = _position;\n        this.surfaceMaterial = new BABYLON.ShaderMaterial(`${this.id}BaseMaterial`, _scene, \"\");\n        this.chunkForge = _forge;\n        this.sides = [\n            new PlanetSide(`${this.id}UpSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Up, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n            new PlanetSide(`${this.id}DownSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Down, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n            new PlanetSide(`${this.id}ForwardSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Forward, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n            new PlanetSide(`${this.id}BackwardSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Backward, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n            new PlanetSide(`${this.id}RightSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Right, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n            new PlanetSide(`${this.id}LeftSide`, _minDepth, _maxDepth, this.chunkLength, Direction.Left, this.attachNode, _scene, this.chunkForge, this.surfaceMaterial, this),\n        ];\n        let nbCraters = 800;\n        let craterRadiusFactor = 1;\n        let craterSteepnessFactor = 1;\n        let craterMaxDepthFactor = 1;\n        this.noiseModifiers = {\n            amplitudeModifier: 1,\n            frequencyModifier: 1,\n            offsetModifier: [0, 0, 0],\n            minValueModifier: 1,\n            archipelagoFactor: 0.5,\n        };\n        this.craterModifiers = {\n            radiusModifier: 1,\n            steepnessModifier: 1,\n            maxDepthModifier: 1,\n            scaleFactor: 1,\n        };\n        this.colorSettings = {\n            snowColor: new BABYLON.Vector3(1, 1, 1),\n            steepColor: new BABYLON.Vector3(0.2, 0.2, 0.2),\n            plainColor: new BABYLON.Vector3(0.5, 0.3, 0.08),\n            sandColor: new BABYLON.Vector3(0.7, 0.7, 0),\n            waterLevel: 0.32,\n            sandSize: 1,\n            steepSharpness: 1\n        };\n        this.craters = this.generateCraters(nbCraters, craterRadiusFactor, craterSteepnessFactor, craterMaxDepthFactor);\n        let surfaceMaterial = new BABYLON.ShaderMaterial(\"surfaceColor\", _scene, \"./shaders/surfaceColor\", {\n            attributes: [\"position\", \"normal\", \"uv\"],\n            uniforms: [\n                \"world\", \"worldViewProjection\", \"projection\", \"view\",\n                \"textureSampler\", \"depthSampler\",\n                \"bottomNormalMap\", \"plainNormalMap\", \"sandNormalMap\", \"snowNormalMap\", \"steepNormalMap\",\n                \"cameraNear\", \"cameraFar\", \"planetPosition\", \"planetRadius\",\n                \"waterLevel\", \"sandSize\", \"steepSharpness\",\n                \"snowColor\", \"steepColor\", \"plainColor\", \"sandColor\"\n            ]\n        });\n        surfaceMaterial.setTexture(\"bottomNormalMap\", new BABYLON.Texture(crackednormal, _scene));\n        surfaceMaterial.setTexture(\"steepNormalMap\", new BABYLON.Texture(rockn, _scene));\n        surfaceMaterial.setTexture(\"plainNormalMap\", new BABYLON.Texture(grassn, _scene));\n        surfaceMaterial.setTexture(\"snowNormalMap\", new BABYLON.Texture(snowNormalMap, _scene));\n        surfaceMaterial.setTexture(\"sandNormalMap\", new BABYLON.Texture(sandNormalMap, _scene));\n        surfaceMaterial.setVector3(\"v3CameraPos\", BABYLON.Vector3.Zero());\n        surfaceMaterial.setVector3(\"v3LightPos\", BABYLON.Vector3.Zero());\n        surfaceMaterial.setVector3(\"planetPosition\", this.attachNode.absolutePosition);\n        surfaceMaterial.setFloat(\"planetRadius\", this.radius);\n        this.setChunkMaterial(surfaceMaterial);\n        this.updateColors();\n    }\n    /**\n     * Sets the material used on the chunks\n     * @param material\n     */\n    setChunkMaterial(material) {\n        this.surfaceMaterial = material;\n        for (let side of this.sides) {\n            side.setChunkMaterial(material);\n        }\n    }\n    /**\n     * Update terrain of the sphere relative to the observer position\n     * @param position the observer position\n     */\n    updateLOD(position, facingDirection) {\n        for (let side of this.sides) {\n            side.updateLOD(position, facingDirection);\n        }\n    }\n    setRenderDistanceFactor(renderDistanceFactor) {\n        for (let side of this.sides) {\n            side.renderDistanceFactor = renderDistanceFactor;\n        }\n    }\n    /**\n     * Changes the maximum depth of the quadtrees\n     * @param maxDepth the new maximum depth of the quadtrees\n     */\n    setMaxDepth(maxDepth) {\n        for (let side of this.sides) {\n            side.maxDepth = maxDepth;\n        }\n    }\n    /**\n     * Changes the minimum depth of the quadtrees\n     * @param minDepth the new minimum depth of the quadtrees\n     */\n    setMinDepth(minDepth) {\n        for (let side of this.sides) {\n            side.minDepth = minDepth;\n        }\n    }\n    /**\n     * Regenerates the chunks\n     */\n    reset() {\n        for (let side of this.sides) {\n            side.reset();\n        }\n    }\n    updateColors() {\n        this.surfaceMaterial.setFloat(\"planetRadius\", this.radius);\n        this.surfaceMaterial.setFloat(\"waterLevel\", this.colorSettings.waterLevel);\n        this.surfaceMaterial.setFloat(\"sandSize\", this.colorSettings.sandSize);\n        this.surfaceMaterial.setFloat(\"steepSharpness\", this.colorSettings.steepSharpness);\n        this.surfaceMaterial.setVector3(\"snowColor\", this.colorSettings.snowColor);\n        this.surfaceMaterial.setVector3(\"steepColor\", this.colorSettings.steepColor);\n        this.surfaceMaterial.setVector3(\"plainColor\", this.colorSettings.plainColor);\n        this.surfaceMaterial.setVector3(\"sandColor\", this.colorSettings.sandColor);\n    }\n    update(position, facingDirection, lightPosition, camera) {\n        this.surfaceMaterial.setVector3(\"v3CameraPos\", position);\n        this.surfaceMaterial.setVector3(\"v3LightPos\", lightPosition);\n        this.updateLOD(position, facingDirection);\n    }\n    generateCraters(n, radiusModifier, _steepness, _maxDepth) {\n        let craters = [];\n        for (let i = 0; i < n; i++) {\n            let r = radiusModifier * 0.1 * (Math.random() ** 16);\n            // random spherical coordinates\n            let phi = Math.random() * Math.PI * 2;\n            let theta = Math.random() * Math.PI;\n            let position = [Math.cos(theta) * Math.sin(phi), Math.sin(theta) * Math.sin(phi), Math.cos(phi)];\n            let maxDepth = _maxDepth * (0.2 + (Math.random()) / 10);\n            let steepness = _steepness * (1 + (Math.random()) / 10) / (r / 2);\n            craters.push({ radius: r, position: position, maxDepth: maxDepth, steepness: steepness });\n        }\n        return craters;\n    }\n}\n","export class AtmosphericScatteringPostProcess extends BABYLON.PostProcess {\n    constructor(name, planet, planetRadius, atmosphereRadius, sun, camera, scene) {\n        super(name, \"./shaders/simplifiedScattering\", [\n            \"sunPosition\",\n            \"cameraPosition\",\n            \"projection\",\n            \"view\",\n            \"transform\",\n            \"cameraNear\",\n            \"cameraFar\",\n            \"cameraDirection\",\n            \"planetPosition\",\n            \"planetRadius\",\n            \"atmosphereRadius\",\n            \"falloffFactor\",\n            \"sunIntensity\",\n            \"scatteringStrength\",\n            \"densityModifier\",\n            \"redWaveLength\",\n            \"greenWaveLength\",\n            \"blueWaveLength\"\n        ], [\n            \"textureSampler\",\n            \"depthSampler\",\n        ], 1, scene.activeCamera, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n        this.settings = {\n            planetRadius: planetRadius,\n            atmosphereRadius: atmosphereRadius,\n            falloffFactor: 15,\n            intensity: 15,\n            scatteringStrength: 1,\n            densityModifier: 1,\n            redWaveLength: 700,\n            greenWaveLength: 530,\n            blueWaveLength: 440,\n        };\n        this.camera = camera;\n        this.sun = sun;\n        this.planet = planet;\n        this.setCamera(this.camera);\n        //let depthMap = depthRenderer.getDepthMap();\n        this.onApply = (effect) => {\n            effect.setTexture(\"depthSampler\", scene.customRenderTargets[0]);\n            effect.setVector3(\"sunPosition\", this.sun.getAbsolutePosition());\n            effect.setVector3(\"cameraPosition\", this.camera.position);\n            effect.setVector3(\"planetPosition\", this.planet.getAbsolutePosition());\n            effect.setMatrix(\"projection\", this.camera.getProjectionMatrix());\n            effect.setMatrix(\"view\", this.camera.getViewMatrix());\n            effect.setMatrix(\"transform\", this.camera.getTransformationMatrix());\n            effect.setFloat(\"cameraNear\", camera.minZ);\n            effect.setFloat(\"cameraFar\", camera.maxZ);\n            effect.setVector3(\"cameraDirection\", camera.getDirection(BABYLON.Axis.Z));\n            effect.setFloat(\"planetRadius\", this.settings.planetRadius);\n            effect.setFloat(\"atmosphereRadius\", this.settings.atmosphereRadius);\n            effect.setFloat(\"falloffFactor\", this.settings.falloffFactor);\n            effect.setFloat(\"sunIntensity\", this.settings.intensity);\n            effect.setFloat(\"scatteringStrength\", this.settings.scatteringStrength);\n            effect.setFloat(\"densityModifier\", this.settings.densityModifier);\n            effect.setFloat(\"redWaveLength\", this.settings.redWaveLength);\n            effect.setFloat(\"greenWaveLength\", this.settings.greenWaveLength);\n            effect.setFloat(\"blueWaveLength\", this.settings.blueWaveLength);\n        };\n    }\n    setCamera(camera) {\n        this.camera.detachPostProcess(this);\n        this.camera = camera;\n        camera.attachPostProcess(this);\n    }\n}\n","import waterbump from \"../../asset/textures/waterbump.png\";\nexport class OceanPostProcess extends BABYLON.PostProcess {\n    constructor(name, planet, oceanRadius, sun, camera, scene) {\n        super(name, \"./shaders/ocean\", [\n            \"sunPosition\",\n            \"cameraPosition\",\n            \"projection\",\n            \"view\",\n            \"transform\",\n            \"cameraNear\",\n            \"cameraFar\",\n            \"cameraDirection\",\n            \"planetPosition\",\n            \"planetRadius\",\n            \"oceanRadius\",\n            \"smoothness\",\n            \"specularPower\",\n            \"alphaModifier\",\n            \"depthModifier\"\n        ], [\n            \"textureSampler\",\n            \"depthSampler\",\n            \"normalMap\"\n        ], 1, camera, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n        this.settings = {\n            oceanRadius: oceanRadius,\n            depthModifier: 1.0,\n            alphaModifier: 0.1,\n            specularPower: 2,\n            smoothness: 0.9,\n        };\n        this.camera = camera;\n        this.sun = sun;\n        this.planet = planet;\n        this.setCamera(this.camera);\n        let depthRenderer = new BABYLON.DepthRenderer(scene);\n        scene.customRenderTargets.push(depthRenderer.getDepthMap());\n        let depthMap = scene.customRenderTargets[0];\n        //this.getEffect().setTexture(\"normalMap\", new BABYLON.Texture(\"./textures/waternormal.jpg\", scene));\n        this.onApply = (effect) => {\n            effect.setTexture(\"depthSampler\", depthMap);\n            effect.setTexture(\"normalMap\", new BABYLON.Texture(waterbump, scene));\n            effect.setVector3(\"sunPosition\", this.sun.getAbsolutePosition());\n            effect.setVector3(\"cameraPosition\", this.camera.position);\n            effect.setVector3(\"planetPosition\", this.planet.absolutePosition);\n            effect.setMatrix(\"projection\", this.camera.getProjectionMatrix());\n            effect.setMatrix(\"view\", this.camera.getViewMatrix());\n            effect.setMatrix(\"transform\", this.camera.getTransformationMatrix());\n            effect.setFloat(\"cameraNear\", camera.minZ);\n            effect.setFloat(\"cameraFar\", camera.maxZ);\n            effect.setVector3(\"cameraDirection\", camera.getDirection(BABYLON.Axis.Z));\n            effect.setFloat(\"oceanRadius\", this.settings.oceanRadius);\n            effect.setFloat(\"smoothness\", this.settings.smoothness);\n            effect.setFloat(\"specularPower\", this.settings.specularPower);\n            effect.setFloat(\"alphaModifier\", this.settings.alphaModifier);\n            effect.setFloat(\"depthModifier\", this.settings.depthModifier);\n        };\n    }\n    setCamera(camera) {\n        this.camera.detachPostProcess(this);\n        this.camera = camera;\n        camera.attachPostProcess(this);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","import { AtmosphericScatteringPostProcess } from \"./postProcesses/atmosphericScatteringPostProcess\";\nimport { Planet } from \"./components/planet\";\nimport { OceanPostProcess } from \"./postProcesses/oceanPostProcess\";\nimport { ChunkForge } from \"./components/forge/chunkForge\";\nimport sunTexture from \"../asset/textures/sun.jpg\";\nlet canvas = document.getElementById(\"renderer\");\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\nlet engine = new BABYLON.Engine(canvas);\nengine.loadingScreen.displayLoadingUI();\nlet scene = new BABYLON.Scene(engine);\nscene.clearColor = new BABYLON.Color4(0, 0, 0, 1);\nlet depthRenderer = new BABYLON.DepthRenderer(scene);\nscene.renderTargetsEnabled = true;\nscene.customRenderTargets.push(depthRenderer.getDepthMap());\ndepthRenderer.getDepthMap().renderList = [];\nlet freeCamera = new BABYLON.FreeCamera(\"freeCamera\", new BABYLON.Vector3(0, 0, 0), scene);\nfreeCamera.minZ = 1;\nfreeCamera.attachControl(canvas);\nlet box = BABYLON.Mesh.CreateBox(\"boate\", 1, scene);\nfreeCamera.parent = box;\nbox.rotate(freeCamera.getDirection(BABYLON.Axis.Y), -1, BABYLON.Space.WORLD);\nscene.activeCamera = freeCamera;\nlet light = new BABYLON.PointLight(\"light\", BABYLON.Vector3.Zero(), scene);\nconst radius = 200 * 1e3; // diamètre en m\nfreeCamera.maxZ = Math.max(radius * 50, 10000);\nlet sun = BABYLON.Mesh.CreateSphere(\"tester\", 32, 0.2 * radius, scene);\nlet mat = new BABYLON.StandardMaterial(\"mat\", scene);\nmat.emissiveTexture = new BABYLON.Texture(sunTexture, scene);\nsun.material = mat;\nlight.parent = sun;\nsun.position.x = -1718573.25;\nsun.position.z = -65566.6171875;\ndepthRenderer.getDepthMap().renderList?.push(sun);\nlet forge = new ChunkForge(64, depthRenderer, scene);\nlet planet = new Planet(\"Arès\", radius, new BABYLON.Vector3(0, 0, 4 * radius), 64, 1, 6, forge, scene);\nplanet.noiseModifiers.archipelagoFactor = 0.5;\nplanet.colorSettings.plainColor = new BABYLON.Vector3(0.1, 0.4, 0);\n//planet.colorSettings.sandColor = planet.colorSettings.plainColor;\nplanet.colorSettings.sandSize = 200;\nplanet.colorSettings.steepSharpness = 6;\nplanet.colorSettings.waterLevel = 10e2;\nplanet.updateColors();\nplanet.attachNode.position.x = radius * 5;\nplanet.attachNode.parent = sun;\nlet moon = new Planet(\"Manaleth\", radius / 8, new BABYLON.Vector3(Math.cos(-0.7), 0, Math.sin(-0.7)).scale(3 * radius), 64, 1, 6, forge, scene);\nmoon.noiseModifiers.archipelagoFactor = 1;\nmoon.colorSettings.plainColor = new BABYLON.Vector3(0.1, 0.1, 0.1);\nmoon.colorSettings.sandColor = planet.colorSettings.steepColor;\nmoon.craterModifiers.maxDepthModifier = 1 / 8;\nmoon.updateColors();\nmoon.attachNode.parent = planet.attachNode;\nplanet.attachNode.parent = sun;\nlet vls = new BABYLON.VolumetricLightScatteringPostProcess(\"trueLight\", 1, scene.activeCamera, sun, 100);\nlet atmosphere = new AtmosphericScatteringPostProcess(\"atmosphere\", planet.attachNode, radius - 15e3, radius + 30e3, sun, freeCamera, scene);\natmosphere.settings.intensity = 10;\natmosphere.settings.falloffFactor = 20;\natmosphere.settings.scatteringStrength = 0.4;\n//let depth = new DepthPostProcess(\"depth\", freeCamera, scene);\nlet ocean = new OceanPostProcess(\"ocean\", planet.attachNode, radius + 10e2, sun, freeCamera, scene);\nocean.settings.alphaModifier = 0.00002;\nocean.settings.depthModifier = 0.004;\n//ocean.settings.oceanRadius = 0;\n//let clouds = new CloudPostProcess(\"clouds\", planet.attachNode, radius + 5e3, radius + 10e3, sun, freeCamera, scene);\nlet keyboard = {};\ndocument.addEventListener(\"keydown\", e => {\n    keyboard[e.key] = true;\n    if (e.key == \"p\") { // take screenshots\n        BABYLON.Tools.CreateScreenshotUsingRenderTarget(engine, scene.activeCamera, { precision: 4 });\n    }\n    if (e.key == \"m\")\n        console.log(sun.absolutePosition, freeCamera.rotation);\n});\ndocument.addEventListener(\"keyup\", e => keyboard[e.key] = false);\nwindow.addEventListener(\"resize\", () => {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    engine.resize();\n});\nscene.executeWhenReady(() => {\n    engine.loadingScreen.hideLoadingUI();\n    let t = 0;\n    let speed = 0.0002 * radius;\n    scene.beforeRender = () => {\n        let forward = freeCamera.getDirection(BABYLON.Axis.Z);\n        let upward = freeCamera.getDirection(BABYLON.Axis.Y);\n        let right = freeCamera.getDirection(BABYLON.Axis.X);\n        forge.update();\n        planet.update(freeCamera.position, forward, sun.position, freeCamera);\n        moon.update(freeCamera.position, forward, sun.position, freeCamera);\n        if (keyboard[\"a\"]) { // rotation autour de l'axe de déplacement\n            box.rotate(forward, 0.02, BABYLON.Space.WORLD);\n        }\n        else if (keyboard[\"e\"]) {\n            box.rotate(forward, -0.02, BABYLON.Space.WORLD);\n        }\n        if (keyboard[\"i\"]) {\n            box.rotate(right, -0.02, BABYLON.Space.WORLD);\n        }\n        else if (keyboard[\"k\"]) {\n            box.rotate(right, 0.02, BABYLON.Space.WORLD);\n        }\n        if (keyboard[\"j\"]) {\n            box.rotate(upward, -0.02, BABYLON.Space.WORLD);\n        }\n        else if (keyboard[\"l\"]) {\n            box.rotate(upward, 0.02, BABYLON.Space.WORLD);\n        }\n        let deplacement = BABYLON.Vector3.Zero();\n        if (keyboard[\"z\"])\n            deplacement.subtractInPlace(forward.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\"s\"])\n            deplacement.addInPlace(forward.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\"q\"])\n            deplacement.addInPlace(right.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\"d\"])\n            deplacement.subtractInPlace(right.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\" \"])\n            deplacement.subtractInPlace(upward.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\"Shift\"])\n            deplacement.addInPlace(upward.scale(speed * engine.getDeltaTime()));\n        if (keyboard[\"+\"])\n            speed *= 1.1;\n        if (keyboard[\"-\"])\n            speed /= 1.1;\n        if (keyboard[\"8\"])\n            speed = 0.03;\n        sun.position.addInPlace(deplacement);\n        t += 0.00002;\n        /*\n        sun.rotation.y = -t;\n        planet.attachNode.rotation.y = -2 * t;\n        */\n        planet.surfaceMaterial.setVector3(\"v3LightPos\", sun.absolutePosition);\n        planet.surfaceMaterial.setVector3(\"planetPosition\", planet.attachNode.absolutePosition);\n        moon.surfaceMaterial.setVector3(\"v3LightPos\", sun.absolutePosition);\n        moon.surfaceMaterial.setVector3(\"planetPosition\", moon.attachNode.absolutePosition);\n    };\n    engine.runRenderLoop(() => {\n        scene.render();\n    });\n});\n"],"names":[],"sourceRoot":""}