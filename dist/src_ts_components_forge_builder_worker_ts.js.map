{"version":3,"file":"src_ts_components_forge_builder_worker_ts.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/EwC;AACuB;AACF;AACX;AACL;AACmB;AACG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAiB;AACtC,2BAA2B,wEAAiB;AAC5C,2BAA2B,4EAAmB;AAC9C,0BAA0B,yEAAkB;AAC5C;AACA;AACA,uBAAuB,sEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAiB,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAgB;AACvC;AACA,iBAAiB,oDAAY;AAC7B,2BAA2B,uDAAiB;AAC5C;AACA,iBAAiB,sDAAc;AAC/B,2BAA2B,uDAAiB;AAC5C;AACA,iBAAiB,yDAAiB;AAClC,2BAA2B,sDAAgB;AAC3C;AACA,iBAAiB,0DAAkB;AACnC,2BAA2B,uDAAiB;AAC5C;AACA,iBAAiB,sDAAc;AAC/B,2BAA2B,uDAAiB;AAC5C;AACA,iBAAiB,uDAAe;AAChC,2BAA2B,uDAAiB;AAC5C;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C,yCAAyC,6CAAO;AAChD;AACA,gCAAgC,uDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;;;;;;;;;;;;;;;AC7IA;AACO;AACP;AACA,mBAAmB;AACnB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,sBAAsB;AACtB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;ACRiC;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BwC;AACN;AAC3B,2BAA2B,2CAAM;AACxC;AACA;AACA;AACA;AACA,wBAAwB,6DAAuB,IAAI,uDAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAgB,IAAI,uDAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1B0E;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,0BAA0B,gFAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://my-webpack-project/./src/ts/components/forge/algebra.ts","webpack://my-webpack-project/./src/ts/components/forge/builder.worker.ts","webpack://my-webpack-project/./src/ts/components/forge/computeNormals.ts","webpack://my-webpack-project/./src/ts/components/forge/direction.ts","webpack://my-webpack-project/./src/ts/components/forge/layers/continentNoiseLayer.ts","webpack://my-webpack-project/./src/ts/components/forge/layers/filters/craterFilter.ts","webpack://my-webpack-project/./src/ts/components/forge/layers/filters/filter.ts","webpack://my-webpack-project/./src/ts/components/forge/layers/moutainNoiseLayer.ts","webpack://my-webpack-project/./src/ts/components/forge/layers/simplexNoiseLayer.ts","webpack://my-webpack-project/./src/ts/engine/noiseTools.ts"],"sourcesContent":["export class Vector3 {\n    constructor(x, y, z) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n    }\n    getSquaredMagnitude() {\n        return this._x ** 2 + this._y ** 2 + this._z ** 2;\n    }\n    getMagnitude() {\n        return Math.sqrt(this.getSquaredMagnitude());\n    }\n    scaleToNew(scaleFactor) {\n        return new Vector3(this._x * scaleFactor, this._y * scaleFactor, this._z * scaleFactor);\n    }\n    addToNew(otherVector) {\n        return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n    }\n    addInPlace(otherVector) {\n        this._x += otherVector._x;\n        this._y += otherVector._y;\n        this._z += otherVector._z;\n    }\n    normalizeToNew() {\n        return this.scaleToNew(1 / this.getMagnitude());\n    }\n    static Zero() {\n        return new Vector3(0, 0, 0);\n    }\n    static FromArray(array) {\n        return new Vector3(array[0], array[1], array[2]);\n    }\n    applyMatrixToNew(matrix) {\n        let newVector = Vector3.Zero();\n        let m = matrix.m;\n        newVector._x = m[0][0] * this._x + m[0][1] * this._y + m[0][2] * this._z;\n        newVector._y = m[1][0] * this._x + m[1][1] * this._y + m[1][2] * this._z;\n        newVector._z = m[2][0] * this._x + m[2][1] * this._y + m[2][2] * this._z;\n        return newVector;\n    }\n    static DistanceSquared(vector1, vector2) {\n        return (vector1._x - vector2._x) ** 2 + (vector1._y - vector2._y) ** 2 + (vector1._z - vector2._z) ** 2;\n    }\n    static Distance(vector1, vector2) {\n        return Math.sqrt(Vector3.DistanceSquared(vector1, vector2));\n    }\n}\nexport class Matrix3 {\n    constructor(values) {\n        this.m = values;\n    }\n    static RotationX(theta) {\n        return new Matrix3([\n            [1, 0, 0],\n            [0, Math.cos(theta), -Math.sin(theta)],\n            [0, Math.sin(theta), Math.cos(theta)]\n        ]);\n    }\n    static RotationY(theta) {\n        return new Matrix3([\n            [Math.cos(theta), 0, Math.sin(theta)],\n            [0, 1, 0],\n            [-Math.sin(theta), 0, Math.cos(theta)]\n        ]);\n    }\n    static RotationZ(theta) {\n        return new Matrix3([\n            [Math.cos(theta), -Math.sin(theta), 0],\n            [Math.sin(theta), Math.cos(theta), 0],\n            [0, 0, 1]\n        ]);\n    }\n    static Identity() {\n        return new Matrix3([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ]);\n    }\n}\n","import { Direction } from \"./direction\";\nimport { SimplexNoiseLayer } from \"./layers/simplexNoiseLayer\";\nimport { CraterFilter } from \"./layers/filters/craterFilter\";\nimport { ComputeNormals } from \"./computeNormals\";\nimport { Matrix3, Vector3 } from \"./algebra\";\nimport { MountainNoiseLayer } from \"./layers/moutainNoiseLayer\";\nimport { ContinentNoiseLayer } from \"./layers/continentNoiseLayer\";\nlet craterModifiers = {\n    radiusModifier: 1,\n    steepnessModifier: 1,\n    maxDepthModifier: 1,\n    scaleFactor: 1,\n};\nlet noiseModifiers = {\n    amplitudeModifier: 1,\n    offsetModifier: [0, 0, 0],\n    frequencyModifier: 1,\n    minValueModifier: 1,\n    archipelagoFactor: 0.5,\n};\nlet bumpyLayer;\nlet continentsLayer2;\nlet continentsLayer3;\nlet mountainsLayer2;\nfunction initLayers() {\n    bumpyLayer = new SimplexNoiseLayer(1e-4, 5, 2, 2, 0.0);\n    continentsLayer2 = new SimplexNoiseLayer(5e-6, 5, 1.8, 2, noiseModifiers.archipelagoFactor);\n    continentsLayer3 = new ContinentNoiseLayer(2e-5, 5, 1.5, 2, 0.0);\n    mountainsLayer2 = new MountainNoiseLayer(2e-5, 6, 2, 2, 0.0);\n}\ninitLayers();\nlet craterFilter = new CraterFilter([]);\nlet moutainHeight = 10000;\nlet bumpyHeight = 300;\nfunction terrainFunction(p, craterFilter, planetRadius) {\n    let initialPosition = [p._x, p._y, p._z];\n    let initialMagnitude = Math.sqrt(initialPosition[0] ** 2 + initialPosition[1] ** 2 + initialPosition[2] ** 2);\n    // on se ramène à la position à la surface du globe (sans relief)\n    initialPosition = initialPosition.map((value) => value * planetRadius / initialMagnitude);\n    let coords = Vector3.FromArray(initialPosition); // p.normalizeToNew().scale(planetRadius);\n    let unitCoords = coords.normalizeToNew().scaleToNew(noiseModifiers.frequencyModifier);\n    let elevation = 0;\n    let craterMask = craterFilter.evaluate(unitCoords, craterModifiers) / 20;\n    elevation += craterMask;\n    let continentMask = continentsLayer2.evaluate(coords);\n    //if (continentMask < 0.1) continentMask = 0;\n    elevation += continentMask * mountainsLayer2.evaluate(coords) * moutainHeight;\n    elevation += bumpyLayer.evaluate(coords) * bumpyHeight;\n    let newPosition = p.addToNew(unitCoords.scaleToNew(elevation));\n    return new Vector3(newPosition._x, newPosition._y, newPosition._z);\n}\n;\nonmessage = e => {\n    if (e.data.taskType == \"buildTask\") {\n        let chunkLength = e.data.chunkLength;\n        let subs = e.data.subdivisions;\n        let depth = e.data.depth;\n        let direction = e.data.direction;\n        let offset = e.data.position;\n        craterFilter.setCraters(e.data.craters);\n        noiseModifiers = e.data.noiseModifiers;\n        craterModifiers = e.data.craterModifiers;\n        initLayers();\n        let size = chunkLength / (2 ** depth);\n        let planetRadius = chunkLength / 2;\n        let vertices = [];\n        let faces = [];\n        //let uvs: number[] = [];\n        let vertexPerLine = subs + 1;\n        let rotation = Matrix3.Identity();\n        switch (direction) {\n            case Direction.Up:\n                rotation = Matrix3.RotationX(-Math.PI / 2);\n                break;\n            case Direction.Down:\n                rotation = Matrix3.RotationX(Math.PI / 2);\n                break;\n            case Direction.Forward:\n                rotation = Matrix3.Identity();\n                break;\n            case Direction.Backward:\n                rotation = Matrix3.RotationY(-Math.PI);\n                break;\n            case Direction.Left:\n                rotation = Matrix3.RotationY(Math.PI / 2);\n                break;\n            case Direction.Right:\n                rotation = Matrix3.RotationY(-Math.PI / 2);\n                break;\n        }\n        for (let x = 0; x < vertexPerLine; x++) {\n            for (let y = 0; y < vertexPerLine; y++) {\n                let vertexPosition = new Vector3((x - subs / 2) / subs, (y - subs / 2) / subs, 0);\n                vertexPosition = vertexPosition.scaleToNew(size);\n                let vecOffset = Vector3.FromArray(offset);\n                vertexPosition = vertexPosition.addToNew(vecOffset);\n                vertexPosition = vertexPosition.applyMatrixToNew(rotation);\n                vertexPosition = vertexPosition.normalizeToNew().scaleToNew(planetRadius);\n                //let offset2 = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.FromArray(offset), rotation);\n                vertexPosition = terrainFunction(vertexPosition, craterFilter, planetRadius);\n                // solving floating point precision\n                //vertexPosition = vertexPosition.subtract(offset2);\n                vertices.push(vertexPosition._x, vertexPosition._y, vertexPosition._z);\n                //uvs.push(x / vertexPerLine, y / vertexPerLine);\n                if (x < vertexPerLine - 1 && y < vertexPerLine - 1) {\n                    faces.push([\n                        x * vertexPerLine + y,\n                        x * vertexPerLine + y + 1,\n                        (x + 1) * vertexPerLine + y + 1,\n                        (x + 1) * vertexPerLine + y,\n                    ]);\n                }\n            }\n        }\n        let positions = vertices;\n        let indices = [];\n        let normals = [];\n        // indices from faces\n        for (let face of faces) {\n            for (let i = 0; i < face.length - 2; i++) {\n                indices.push(face[0], face[i + 2], face[i + 1]);\n            }\n        }\n        ComputeNormals(positions, indices, normals);\n        let tPositions = new Float32Array(positions.length);\n        tPositions.set(positions);\n        let tIndices = new Int16Array(indices.length);\n        tIndices.set(indices);\n        let tNormals = new Float32Array(normals.length);\n        tNormals.set(normals);\n        //@ts-ignore\n        postMessage({\n            p: tPositions,\n            i: tIndices,\n            n: tNormals,\n            //@ts-ignore\n        }, [tPositions.buffer, tIndices.buffer, tNormals.buffer]);\n    }\n    else {\n        console.log(`Tâche reçue : ${e.data.taskType}`);\n    }\n};\n","//https://github.com/BabylonJS/Babylon.js/blob/master/src/Meshes/mesh.vertexData.ts\nexport function ComputeNormals(positions, indices, normals) {\n    // temporary scalar variables\n    var index = 0; // facet index\n    var p1p2x = 0.0; // p1p2 vector x coordinate\n    var p1p2y = 0.0; // p1p2 vector y coordinate\n    var p1p2z = 0.0; // p1p2 vector z coordinate\n    var p3p2x = 0.0; // p3p2 vector x coordinate\n    var p3p2y = 0.0; // p3p2 vector y coordinate\n    var p3p2z = 0.0; // p3p2 vector z coordinate\n    var faceNormalx = 0.0; // facet normal x coordinate\n    var faceNormaly = 0.0; // facet normal y coordinate\n    var faceNormalz = 0.0; // facet normal z coordinate\n    var length = 0.0; // facet normal length before normalization\n    var v1x = 0; // vector1 x index in the positions array\n    var v1y = 0; // vector1 y index in the positions array\n    var v1z = 0; // vector1 z index in the positions array\n    var v2x = 0; // vector2 x index in the positions array\n    var v2y = 0; // vector2 y index in the positions array\n    var v2z = 0; // vector2 z index in the positions array\n    var v3x = 0; // vector3 x index in the positions array\n    var v3y = 0; // vector3 y index in the positions array\n    var v3z = 0; // vector3 z index in the positions array\n    var faceNormalSign = 1;\n    // reset the normals\n    for (index = 0; index < positions.length; index++) {\n        normals[index] = 0.0;\n    }\n    // Loop : 1 indice triplet = 1 facet\n    var nbFaces = (indices.length / 3) | 0;\n    for (index = 0; index < nbFaces; index++) {\n        // get the indexes of the coordinates of each vertex of the facet\n        v1x = indices[index * 3] * 3;\n        v1y = v1x + 1;\n        v1z = v1x + 2;\n        v2x = indices[index * 3 + 1] * 3;\n        v2y = v2x + 1;\n        v2z = v2x + 2;\n        v3x = indices[index * 3 + 2] * 3;\n        v3y = v3x + 1;\n        v3z = v3x + 2;\n        p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n        p1p2y = positions[v1y] - positions[v2y];\n        p1p2z = positions[v1z] - positions[v2z];\n        p3p2x = positions[v3x] - positions[v2x];\n        p3p2y = positions[v3y] - positions[v2y];\n        p3p2z = positions[v3z] - positions[v2z];\n        // compute the face normal with the cross product\n        faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n        faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n        faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n        // normalize this normal and store it in the array facetData\n        length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n        length = (length === 0) ? 1.0 : length;\n        faceNormalx /= length;\n        faceNormaly /= length;\n        faceNormalz /= length;\n        // compute the normals anyway\n        normals[v1x] += faceNormalx; // accumulate all the normals per face\n        normals[v1y] += faceNormaly;\n        normals[v1z] += faceNormalz;\n        normals[v2x] += faceNormalx;\n        normals[v2y] += faceNormaly;\n        normals[v2z] += faceNormalz;\n        normals[v3x] += faceNormalx;\n        normals[v3y] += faceNormaly;\n        normals[v3z] += faceNormalz;\n    }\n    // last normalization of each normal\n    for (index = 0; index < normals.length / 3; index++) {\n        faceNormalx = normals[index * 3];\n        faceNormaly = normals[index * 3 + 1];\n        faceNormalz = normals[index * 3 + 2];\n        length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n        length = (length === 0) ? 1.0 : length;\n        faceNormalx /= length;\n        faceNormaly /= length;\n        faceNormalz /= length;\n        normals[index * 3] = faceNormalx;\n        normals[index * 3 + 1] = faceNormaly;\n        normals[index * 3 + 2] = faceNormalz;\n    }\n}\n","export var Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n    Direction[Direction[\"Left\"] = 2] = \"Left\";\n    Direction[Direction[\"Right\"] = 3] = \"Right\";\n    Direction[Direction[\"Forward\"] = 4] = \"Forward\";\n    Direction[Direction[\"Backward\"] = 5] = \"Backward\";\n})(Direction || (Direction = {}));\n","import { simplex3FromVector } from \"../../../engine/noiseTools\";\nexport class ContinentNoiseLayer {\n    constructor(frequency, nbOctaves, decay, lacunarity, minValue) {\n        this._frequency = frequency;\n        this._nbOctaves = nbOctaves;\n        this._decay = decay;\n        this._lacunarity = lacunarity;\n        this._minValue = minValue;\n    }\n    evaluate(coords) {\n        let noiseValue = 0.0;\n        let totalAmplitude = 0.0;\n        for (let i = 0; i < this._nbOctaves; i++) {\n            let samplePoint = coords.scaleToNew(this._frequency);\n            samplePoint = samplePoint.scaleToNew(Math.pow(this._lacunarity, i));\n            noiseValue += simplex3FromVector(samplePoint) / Math.pow(this._decay, i);\n            totalAmplitude += 1.0 / Math.pow(this._decay, i);\n        }\n        noiseValue /= totalAmplitude;\n        noiseValue = Math.pow(noiseValue, 2);\n        if (this._minValue < 1) {\n            noiseValue = Math.max(this._minValue, noiseValue) - this._minValue;\n            noiseValue /= 1.0 - this._minValue;\n        }\n        let riverFactor = 0.95;\n        noiseValue *= riverFactor;\n        noiseValue += 1 - riverFactor;\n        return noiseValue;\n    }\n}\n","import { Vector3 } from \"../../algebra\";\nimport { Filter } from \"./filter\";\nexport class CraterFilter extends Filter {\n    constructor(craters) {\n        super((p, s) => {\n            let elevation = 0;\n            for (let crater of craters) {\n                let d = Vector3.DistanceSquared(p, Vector3.FromArray(crater.position));\n                let radius = crater.radius * s.radiusModifier;\n                let steepness = crater.steepness * s.steepnessModifier;\n                //console.log(crater.position);\n                if (d * 1e100 <= radius ** 2) {\n                    //let depth = 10;\n                    //let height = depth * (d / ((radius) ** 2)) - depth;\n                    //let border = 100 * depth * radius ** 2 * (((Math.sqrt(d) / radius) - 1) ** 2);\n                    //let border = 10 * Math.exp(-d * 1000); //- depth / 100;\n                    //let plancher = Math.max(height, -depth * 0.3);\n                    //elevation += border;\n                    //elevation += Math.max(height, plancher);\n                    //elevation += Math.min(height, border);\n                    //elevation += Math.max(Math.min(height, border), plancher);\n                    //let height = Math.min((d / ((radius * steepness) ** 2)) - 0.4, 0.05);\n                    //height = Math.max(height, -crater.maxDepth * s.maxDepthModifier) * s.scaleFactor;\n                    //elevation += height;\n                    //elevation -= 1e3 * 100;\n                }\n            }\n            return elevation;\n        });\n    }\n    setCraters(craters) {\n        this.filterFunction = (p, s) => {\n            let elevation = 0;\n            for (let crater of craters) {\n                let d = Vector3.Distance(p, Vector3.FromArray(crater.position));\n                let radius = crater.radius * s.radiusModifier;\n                let steepness = crater.steepness * s.steepnessModifier;\n                if (d <= radius) {\n                    /*function smin(a: number, b: number, k: number) {\n                        let res = Math.exp(-k * a) + Math.exp(-k * b);\n                        return -Math.log(res) / k;\n                    }*/\n                    let depth = (d / radius) ** (16 * s.steepnessModifier) - 1;\n                    elevation += 300 * 1e3 * radius * depth * s.maxDepthModifier;\n                }\n            }\n            return elevation;\n        };\n    }\n}\n","export class Filter {\n    constructor(_filterFunction) {\n        this.filterFunction = _filterFunction;\n    }\n    evaluate(p, s) {\n        return this.filterFunction(p, s);\n    }\n}\n","import { simplex3FromVector } from \"../../../engine/noiseTools\";\nexport class MountainNoiseLayer {\n    constructor(frequency, nbOctaves, decay, lacunarity, minValue) {\n        this._frequency = frequency;\n        this._nbOctaves = nbOctaves;\n        this._decay = decay;\n        this._lacunarity = lacunarity;\n        this._minValue = minValue;\n    }\n    evaluate(coords) {\n        let noiseValue = 0.0;\n        let totalAmplitude = 0.0;\n        for (let i = 0; i < this._nbOctaves; i++) {\n            let samplePoint = coords.scaleToNew(this._frequency);\n            samplePoint = samplePoint.scaleToNew(Math.pow(this._lacunarity, i));\n            noiseValue += simplex3FromVector(samplePoint) / Math.pow(this._decay, i);\n            totalAmplitude += 1.0 / Math.pow(this._decay, i);\n        }\n        noiseValue /= totalAmplitude;\n        noiseValue = 1 - Math.abs(noiseValue);\n        if (this._minValue < 1) {\n            noiseValue = Math.max(this._minValue, noiseValue) - this._minValue;\n            noiseValue /= 1.0 - this._minValue;\n        }\n        return noiseValue;\n    }\n}\n","import { normalizedSimplex3FromVector } from \"../../../engine/noiseTools\";\nexport class SimplexNoiseLayer {\n    constructor(frequency, nbOctaves, decay, lacunarity, minValue) {\n        this._frequency = frequency;\n        this._nbOctaves = nbOctaves;\n        this._decay = decay;\n        this._lacunarity = lacunarity;\n        this._minValue = minValue;\n    }\n    evaluate(coords) {\n        let noiseValue = 0.0;\n        let totalAmplitude = 0.0;\n        for (let i = 0; i < this._nbOctaves; i++) {\n            let samplePoint = coords.scaleToNew(this._frequency);\n            samplePoint = samplePoint.scaleToNew(Math.pow(this._lacunarity, i));\n            noiseValue += normalizedSimplex3FromVector(samplePoint) / Math.pow(this._decay, i);\n            totalAmplitude += 1.0 / Math.pow(this._decay, i);\n        }\n        noiseValue /= totalAmplitude;\n        if (this._minValue != 1) {\n            noiseValue = Math.max(this._minValue, noiseValue) - this._minValue;\n            noiseValue /= 1.0 - this._minValue;\n            //noiseValue += this._minValue;\n        }\n        return noiseValue;\n    }\n}\n","/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\nclass Grad {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    dot2(x, y) {\n        return this.x * x + this.y * y;\n    }\n    dot3(x, y, z) {\n        return this.x * x + this.y * y + this.z * z;\n    }\n}\nlet grad3 = [\n    new Grad(1, 1, 0),\n    new Grad(-1, 1, 0),\n    new Grad(1, -1, 0),\n    new Grad(-1, -1, 0),\n    new Grad(1, 0, 1),\n    new Grad(-1, 0, 1),\n    new Grad(1, 0, -1),\n    new Grad(-1, 0, -1),\n    new Grad(0, 1, 1),\n    new Grad(0, -1, 1),\n    new Grad(0, 1, -1),\n    new Grad(0, -1, -1),\n];\nlet p = [\n    151,\n    160,\n    137,\n    91,\n    90,\n    15,\n    131,\n    13,\n    201,\n    95,\n    96,\n    53,\n    194,\n    233,\n    7,\n    225,\n    140,\n    36,\n    103,\n    30,\n    69,\n    142,\n    8,\n    99,\n    37,\n    240,\n    21,\n    10,\n    23,\n    190,\n    6,\n    148,\n    247,\n    120,\n    234,\n    75,\n    0,\n    26,\n    197,\n    62,\n    94,\n    252,\n    219,\n    203,\n    117,\n    35,\n    11,\n    32,\n    57,\n    177,\n    33,\n    88,\n    237,\n    149,\n    56,\n    87,\n    174,\n    20,\n    125,\n    136,\n    171,\n    168,\n    68,\n    175,\n    74,\n    165,\n    71,\n    134,\n    139,\n    48,\n    27,\n    166,\n    77,\n    146,\n    158,\n    231,\n    83,\n    111,\n    229,\n    122,\n    60,\n    211,\n    133,\n    230,\n    220,\n    105,\n    92,\n    41,\n    55,\n    46,\n    245,\n    40,\n    244,\n    102,\n    143,\n    54,\n    65,\n    25,\n    63,\n    161,\n    1,\n    216,\n    80,\n    73,\n    209,\n    76,\n    132,\n    187,\n    208,\n    89,\n    18,\n    169,\n    200,\n    196,\n    135,\n    130,\n    116,\n    188,\n    159,\n    86,\n    164,\n    100,\n    109,\n    198,\n    173,\n    186,\n    3,\n    64,\n    52,\n    217,\n    226,\n    250,\n    124,\n    123,\n    5,\n    202,\n    38,\n    147,\n    118,\n    126,\n    255,\n    82,\n    85,\n    212,\n    207,\n    206,\n    59,\n    227,\n    47,\n    16,\n    58,\n    17,\n    182,\n    189,\n    28,\n    42,\n    223,\n    183,\n    170,\n    213,\n    119,\n    248,\n    152,\n    2,\n    44,\n    154,\n    163,\n    70,\n    221,\n    153,\n    101,\n    155,\n    167,\n    43,\n    172,\n    9,\n    129,\n    22,\n    39,\n    253,\n    19,\n    98,\n    108,\n    110,\n    79,\n    113,\n    224,\n    232,\n    178,\n    185,\n    112,\n    104,\n    218,\n    246,\n    97,\n    228,\n    251,\n    34,\n    242,\n    193,\n    238,\n    210,\n    144,\n    12,\n    191,\n    179,\n    162,\n    241,\n    81,\n    51,\n    145,\n    235,\n    249,\n    14,\n    239,\n    107,\n    49,\n    192,\n    214,\n    31,\n    181,\n    199,\n    106,\n    157,\n    184,\n    84,\n    204,\n    176,\n    115,\n    121,\n    50,\n    45,\n    127,\n    4,\n    150,\n    254,\n    138,\n    236,\n    205,\n    93,\n    222,\n    114,\n    67,\n    29,\n    24,\n    72,\n    243,\n    141,\n    128,\n    195,\n    78,\n    66,\n    215,\n    61,\n    156,\n    180,\n];\n// To remove the need for index wrapping, double the permutation table length\nlet perm = new Array(512);\nlet gradP = new Array(512);\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\nfunction seed(seed) {\n    if (seed > 0 && seed < 1) {\n        // Scale the seed out\n        seed *= 65536;\n    }\n    seed = Math.floor(seed);\n    if (seed < 256) {\n        seed |= seed << 8;\n    }\n    for (let i = 0; i < 256; i++) {\n        let v;\n        if (i & 1) {\n            v = p[i] ^ (seed & 255);\n        }\n        else {\n            v = p[i] ^ ((seed >> 8) & 255);\n        }\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n}\nfunction simplex2(xin, yin) {\n    let n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    let s = (xin + yin) * F2; // Hairy factor for 2D\n    let i = Math.floor(xin + s);\n    let j = Math.floor(yin + s);\n    let t = (i + j) * G2;\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    let y0 = yin - j + t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) {\n        // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1 = 1;\n        j1 = 0;\n    }\n    else {\n        // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1 = 0;\n        j1 = 1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    let y1 = y0 - j1 + G2;\n    let x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    let y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    let gi0 = gradP[i + perm[j]];\n    let gi1 = gradP[i + i1 + perm[j + j1]];\n    let gi2 = gradP[i + 1 + perm[j + 1]];\n    // Calculate the contribution from the three corners\n    let t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 < 0) {\n        n0 = 0;\n    }\n    else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n    }\n    let t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 < 0) {\n        n1 = 0;\n    }\n    else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    let t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 < 0) {\n        n2 = 0;\n    }\n    else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n}\n/**\n *\n * @param vector\n * @returns simplex between 0 and 1\n */\nexport function normalizedSimplex3FromVector(vector) {\n    return (1 + simplex3(vector._x, vector._y, vector._z)) / 2;\n}\n/**\n *\n * @param vector\n * @returns simplex between -1 and 1\n */\nexport function simplex3FromVector(vector) {\n    return simplex3(vector._x, vector._y, vector._z);\n}\nfunction simplex3(xin, yin, zin) {\n    seed(42);\n    let n0, n1, n2, n3; // Noise contributions from the four corners\n    // Skew the input space to determine which simplex cell we're in\n    let s = (xin + yin + zin) * F3; // Hairy factor for 2D\n    let i = Math.floor(xin + s);\n    let j = Math.floor(yin + s);\n    let k = Math.floor(zin + s);\n    let t = (i + j + k) * G3;\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    let y0 = yin - j + t;\n    let z0 = zin - k + t;\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if (x0 >= y0) {\n        if (y0 >= z0) {\n            i1 = 1;\n            j1 = 0;\n            k1 = 0;\n            i2 = 1;\n            j2 = 1;\n            k2 = 0;\n        }\n        else if (x0 >= z0) {\n            i1 = 1;\n            j1 = 0;\n            k1 = 0;\n            i2 = 1;\n            j2 = 0;\n            k2 = 1;\n        }\n        else {\n            i1 = 0;\n            j1 = 0;\n            k1 = 1;\n            i2 = 1;\n            j2 = 0;\n            k2 = 1;\n        }\n    }\n    else {\n        if (y0 < z0) {\n            i1 = 0;\n            j1 = 0;\n            k1 = 1;\n            i2 = 0;\n            j2 = 1;\n            k2 = 1;\n        }\n        else if (x0 < z0) {\n            i1 = 0;\n            j1 = 1;\n            k1 = 0;\n            i2 = 0;\n            j2 = 1;\n            k2 = 1;\n        }\n        else {\n            i1 = 0;\n            j1 = 1;\n            k1 = 0;\n            i2 = 1;\n            j2 = 1;\n            k2 = 0;\n        }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    let x1 = x0 - i1 + G3; // Offsets for second corner\n    let y1 = y0 - j1 + G3;\n    let z1 = z0 - k1 + G3;\n    let x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    let y2 = y0 - j2 + 2 * G3;\n    let z2 = z0 - k2 + 2 * G3;\n    let x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    let y3 = y0 - 1 + 3 * G3;\n    let z3 = z0 - 1 + 3 * G3;\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n    let gi0 = gradP[i + perm[j + perm[k]]];\n    let gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n    let gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n    let gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];\n    // Calculate the contribution from the four corners\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n    if (t0 < 0) {\n        n0 = 0;\n    }\n    else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n    }\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n    if (t1 < 0) {\n        n1 = 0;\n    }\n    else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n    if (t2 < 0) {\n        n2 = 0;\n    }\n    else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n    if (t3 < 0) {\n        n3 = 0;\n    }\n    else {\n        t3 *= t3;\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n}\nfunction fade(t) {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n}\nfunction lerp(a, b, t) {\n    return (1 - t) * a + t * b;\n}\n"],"names":[],"sourceRoot":""}