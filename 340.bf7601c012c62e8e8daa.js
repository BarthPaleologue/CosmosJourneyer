
//  This file is part of Cosmos Journeyer
//
//  Copyright (C) 2024 Barthélemy Paléologue <barth.paleologue@cosmosjourneyer.com>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Affero General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Affero General Public License for more details.
//
//  You should have received a copy of the GNU Affero General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
        
"use strict";(self.webpackChunkcosmos_journeyer=self.webpackChunkcosmos_journeyer||[]).push([[340],{17407:(e,t,r)=>{var a=r(44838),o=r(52101),n=r(64800),l=r(45892),s=r(9370),f=r(62762);s.$.prototype._partialLoadFile=function(e,t,r,a,o=null){this._loadFile(e,(e=>{r[t]=e,r._internalCount++,6===r._internalCount&&a(r)}),void 0,void 0,!0,((e,t)=>{o&&e&&o(e.status+" "+e.statusText,t)}))},s.$.prototype._cascadeLoadFiles=function(e,t,r,a=null){const o=[];o._internalCount=0;for(let e=0;e<6;e++)this._partialLoadFile(r[e],e,o,t,a)},s.$.prototype._cascadeLoadImgs=function(e,t,r,a,o=null,n){const l=[];l._internalCount=0;for(let s=0;s<6;s++)this._partialLoadImg(a[s],s,l,e,t,r,o,n)},s.$.prototype._partialLoadImg=function(e,t,r,a,o,s,f=null,i){const u=(0,l.z)();(0,n.W$)(e,(e=>{r[t]=e,r._internalCount++,a&&a.removePendingData(u),6===r._internalCount&&s&&s(o,r)}),((e,t)=>{a&&a.removePendingData(u),f&&f(e,t)}),a?a.offlineProvider:null,i),a&&a.addPendingData(u)},s.$.prototype.createCubeTextureBase=function(e,t,r,n,l=null,s=null,i,u=null,c=!1,A=0,d=0,p=null,y=null,h=null,_=!1,C=null){const b=p||new a.h(this,7);b.isCube=!0,b.url=e,b.generateMipMaps=!n,b._lodGenerationScale=A,b._lodGenerationOffset=d,b._useSRGBBuffer=!!_&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!n),b!==p&&(b.label=e.substring(0,60)),this._doNotHandleContextLost||(b._extension=u,b._files=r,b._buffer=C);const B=e;this._transformTextureUrl&&!p&&(e=this._transformTextureUrl(e));const G=e.split("?")[0],m=G.lastIndexOf("."),F=u||(m>-1?G.substring(m).toLowerCase():""),w=(0,f.gT)(F),x=(a,f)=>{e===B?s&&a&&s(a.status+" "+a.statusText,f):(o.V.Warn(`Failed to load ${e}, falling back to the ${B}`),this.createCubeTextureBase(B,t,r,!!n,l,s,i,u,c,A,d,b,y,h,_,C))};if(w)w.then((a=>{const n=e=>{y&&y(b,e),a.loadCubeData(e,b,c,l,s)};C?n(C):r&&6===r.length?a.supportCascades?this._cascadeLoadFiles(t,(e=>n(e.map((e=>new Uint8Array(e))))),r,s):s?s("Textures type does not support cascades."):o.V.Warn("Texture loader does not support cascades."):this._loadFile(e,(e=>n(new Uint8Array(e))),void 0,void 0,!0,x)}));else{if(!r||0===r.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(t,b,((e,t)=>{h&&h(e,t)}),r,s)}return this._internalTexturesCache.push(b),b}},62340:(e,t,r)=>{r.d(t,{DDSTools:()=>p});var a=r(33583),o=r(52101),n=r(61583),l=r(5055);r(17407);const s=131072,f=131072;function i(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}const u=i("DXT1"),c=i("DXT3"),A=i("DXT5"),d=i("DX10");class p{static GetDDSInfo(e){const t=new Int32Array(e.buffer,e.byteOffset,31),r=new Int32Array(e.buffer,e.byteOffset,35);let a=1;t[2]&s&&(a=Math.max(1,t[7]));const o=t[21],n=o===d?r[32]:0;let l=0;switch(o){case 113:l=2;break;case 116:l=1;break;case d:if(10===n){l=2;break}if(2===n){l=1;break}}return{width:t[4],height:t[3],mipmapCount:a,isFourCC:!(4&~t[20]),isRGB:!(64&~t[20]),isLuminance:(t[20]&f)===f,isCube:!(512&~t[28]),isCompressed:o===u||o===c||o===A,dxgiFormat:n,textureType:l}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,t,r,a,o,n){const s=new Float32Array(a),f=new Uint16Array(o,r);let i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);s[i]=(0,l.SX)(f[a]),s[i+1]=(0,l.SX)(f[a+1]),s[i+2]=(0,l.SX)(f[a+2]),p.StoreLODInAlphaChannel?s[i+3]=n:s[i+3]=(0,l.SX)(f[a+3]),i+=4}return s}static _GetHalfFloatRGBAArrayBuffer(e,t,r,a,o,n){if(p.StoreLODInAlphaChannel){const s=new Uint16Array(a),f=new Uint16Array(o,r);let i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);s[i]=f[a],s[i+1]=f[a+1],s[i+2]=f[a+2],s[i+3]=(0,l.LZ)(n),i+=4}return s}return new Uint16Array(o,r,a)}static _GetFloatRGBAArrayBuffer(e,t,r,a,o,n){if(p.StoreLODInAlphaChannel){const l=new Float32Array(a),s=new Float32Array(o,r);let f=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);l[f]=s[a],l[f+1]=s[a+1],l[f+2]=s[a+2],l[f+3]=n,f+=4}return l}return new Float32Array(o,r,a)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,t,r,a,o,n){const s=new Uint16Array(a),f=new Float32Array(o,r);let i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++)s[i]=(0,l.LZ)(f[i]),s[i+1]=(0,l.LZ)(f[i+1]),s[i+2]=(0,l.LZ)(f[i+2]),p.StoreLODInAlphaChannel?s[i+3]=(0,l.LZ)(n):s[i+3]=(0,l.LZ)(f[i+3]),i+=4;return s}static _GetFloatAsUIntRGBAArrayBuffer(e,t,r,o,n,l){const s=new Uint8Array(o),f=new Float32Array(n,r);let i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const o=4*(t+r*e);s[i]=255*(0,a.Clamp)(f[o]),s[i+1]=255*(0,a.Clamp)(f[o+1]),s[i+2]=255*(0,a.Clamp)(f[o+2]),p.StoreLODInAlphaChannel?s[i+3]=l:s[i+3]=255*(0,a.Clamp)(f[o+3]),i+=4}return s}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,t,r,o,n,s){const f=new Uint8Array(o),i=new Uint16Array(n,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const o=4*(t+r*e);f[u]=255*(0,a.Clamp)((0,l.SX)(i[o])),f[u+1]=255*(0,a.Clamp)((0,l.SX)(i[o+1])),f[u+2]=255*(0,a.Clamp)((0,l.SX)(i[o+2])),p.StoreLODInAlphaChannel?f[u+3]=s:f[u+3]=255*(0,a.Clamp)((0,l.SX)(i[o+3])),u+=4}return f}static _GetRGBAArrayBuffer(e,t,r,a,o,n,l,s,f){const i=new Uint8Array(a),u=new Uint8Array(o,r);let c=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);i[c]=u[a+n],i[c+1]=u[a+l],i[c+2]=u[a+s],i[c+3]=u[a+f],c+=4}return i}static _ExtractLongWordOrder(e){return 0===e||255===e||-16777216===e?0:1+p._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,t,r,a,o,n,l,s){const f=new Uint8Array(a),i=new Uint8Array(o,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=3*(t+r*e);f[u]=i[a+n],f[u+1]=i[a+l],f[u+2]=i[a+s],u+=3}return f}static _GetLuminanceArrayBuffer(e,t,r,a,o){const n=new Uint8Array(a),l=new Uint8Array(o,r);let s=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=t+r*e;n[s]=l[a],s++}return n}static UploadDDSLevels(e,t,r,a,l,f,i=-1,y,h=!0){let _=null;a.sphericalPolynomial&&(_=[]);const C=!!e.getCaps().s3tc;t.generateMipMaps=l;const b=new Int32Array(r.buffer,r.byteOffset,31);let B,G,m,F,w,x,L,g=0,D=0,R=1;if(542327876!==b[0])return void o.V.Error("Invalid magic number in DDS header");if(!a.isFourCC&&!a.isRGB&&!a.isLuminance)return void o.V.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(a.isCompressed&&!C)return void o.V.Error("Compressed textures are not supported on this platform.");let U=b[22];F=b[1]+4;let O=!1;if(a.isFourCC)switch(B=b[21],B){case u:R=8,D=33777;break;case c:R=16,D=33778;break;case A:R=16,D=33779;break;case 113:O=!0,U=64;break;case 116:O=!0,U=128;break;case d:{F+=20;let e=!1;switch(a.dxgiFormat){case 10:O=!0,U=64,e=!0;break;case 2:O=!0,U=128,e=!0;break;case 88:a.isRGB=!0,a.isFourCC=!1,U=32,e=!0}if(e)break}default:return void o.V.Error(["Unsupported FourCC code:",(S=B,String.fromCharCode(255&S,S>>8&255,S>>16&255,S>>24&255))])}var S;const T=p._ExtractLongWordOrder(b[23]),k=p._ExtractLongWordOrder(b[24]),I=p._ExtractLongWordOrder(b[25]),v=p._ExtractLongWordOrder(b[26]);O&&(D=e._getRGBABufferInternalSizedFormat(a.textureType)),x=1,b[2]&s&&!1!==l&&(x=Math.max(1,b[7]));const H=y||0,M=e.getCaps();for(let o=H;o<f;o++){for(G=b[4],m=b[3],L=0;L<x;++L){if(-1===i||i===L){const n=-1===i?L:0;if(!a.isCompressed&&a.isFourCC){t.format=5,g=G*m*4;let a=null;if(e._badOS||e._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)128===U?(a=p._GetFloatAsUIntRGBAArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,n),_&&0==n&&_.push(p._GetFloatRGBAArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,n))):64===U&&(a=p._GetHalfFloatAsUIntRGBAArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,n),_&&0==n&&_.push(p._GetHalfFloatAsFloatRGBAArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,n))),t.type=0;else{const e=M.textureFloat&&(h&&M.textureFloatLinearFiltering||!h),o=M.textureHalfFloat&&(h&&M.textureHalfFloatLinearFiltering||!h),l=(128===U||64===U&&!o)&&e?1:(64===U||128===U&&!e)&&o?2:0;let s,f=null;if(128===U)switch(l){case 1:s=p._GetFloatRGBAArrayBuffer,f=null;break;case 2:s=p._GetFloatAsHalfFloatRGBAArrayBuffer,f=p._GetFloatRGBAArrayBuffer;break;case 0:s=p._GetFloatAsUIntRGBAArrayBuffer,f=p._GetFloatRGBAArrayBuffer}else switch(l){case 1:s=p._GetHalfFloatAsFloatRGBAArrayBuffer,f=null;break;case 2:s=p._GetHalfFloatRGBAArrayBuffer,f=p._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:s=p._GetHalfFloatAsUIntRGBAArrayBuffer,f=p._GetHalfFloatAsFloatRGBAArrayBuffer}t.type=l,a=s(G,m,r.byteOffset+F,g,r.buffer,n),_&&0==n&&_.push(f?f(G,m,r.byteOffset+F,g,r.buffer,n):a)}a&&e._uploadDataToTextureDirectly(t,a,o,n)}else if(a.isRGB)t.type=0,24===U?(t.format=4,g=G*m*3,w=p._GetRGBArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,T,k,I),e._uploadDataToTextureDirectly(t,w,o,n)):(t.format=5,g=G*m*4,w=p._GetRGBAArrayBuffer(G,m,r.byteOffset+F,g,r.buffer,T,k,I,v),e._uploadDataToTextureDirectly(t,w,o,n));else if(a.isLuminance){const a=e._getUnpackAlignement(),l=G;g=Math.floor((G+a-1)/a)*a*(m-1)+l,w=p._GetLuminanceArrayBuffer(G,m,r.byteOffset+F,g,r.buffer),t.format=1,t.type=0,e._uploadDataToTextureDirectly(t,w,o,n)}else g=Math.max(4,G)/4*Math.max(4,m)/4*R,w=new Uint8Array(r.buffer,r.byteOffset+F,g),t.type=0,e._uploadCompressedDataToTextureDirectly(t,D,G,m,w,o,n)}F+=U?G*m*(U/8):g,G*=.5,m*=.5,G=Math.max(1,G),m=Math.max(1,m)}if(void 0!==y)break}_&&_.length>0?a.sphericalPolynomial=n.d.ConvertCubeMapToSphericalPolynomial({size:b[4],right:_[0],left:_[1],up:_[2],down:_[3],front:_[4],back:_[5],format:5,type:1,gammaSpace:!1}):a.sphericalPolynomial=void 0}}p.StoreLODInAlphaChannel=!1}}]);